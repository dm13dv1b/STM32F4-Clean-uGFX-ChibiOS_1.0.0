
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	482e      	ldr	r0, [pc, #184]	; (800027c <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	f240 0000 	movw	r0, #0
 80001cc:	f2cc 0000 	movt	r0, #49152	; 0xc000
 80001d0:	f64e 7134 	movw	r1, #61236	; 0xef34
 80001d4:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d8:	6008      	str	r0, [r1, #0]
 80001da:	f240 0000 	movw	r0, #0
 80001de:	f2c0 00f0 	movt	r0, #240	; 0xf0
 80001e2:	f64e 5188 	movw	r1, #60808	; 0xed88
 80001e6:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001ea:	6008      	str	r0, [r1, #0]
 80001ec:	f04f 0000 	mov.w	r0, #0
 80001f0:	eee1 0a10 	vmsr	fpscr, r0
 80001f4:	f64e 713c 	movw	r1, #61244	; 0xef3c
 80001f8:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001fc:	6008      	str	r0, [r1, #0]
 80001fe:	2006      	movs	r0, #6
 8000200:	f380 8814 	msr	CONTROL, r0
 8000204:	f3bf 8f6f 	isb	sy
 8000208:	f002 fe0a 	bl	8002e20 <__early_init>
 800020c:	481c      	ldr	r0, [pc, #112]	; (8000280 <endfiniloop+0xa>)
 800020e:	491d      	ldr	r1, [pc, #116]	; (8000284 <endfiniloop+0xe>)
 8000210:	4a1d      	ldr	r2, [pc, #116]	; (8000288 <endfiniloop+0x12>)

08000212 <msloop>:
 8000212:	4291      	cmp	r1, r2
 8000214:	bf3c      	itt	cc
 8000216:	f841 0b04 	strcc.w	r0, [r1], #4
 800021a:	e7fa      	bcc.n	8000212 <msloop>
 800021c:	491b      	ldr	r1, [pc, #108]	; (800028c <endfiniloop+0x16>)
 800021e:	4a17      	ldr	r2, [pc, #92]	; (800027c <endfiniloop+0x6>)

08000220 <psloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	e7fa      	bcc.n	8000220 <psloop>
 800022a:	4919      	ldr	r1, [pc, #100]	; (8000290 <endfiniloop+0x1a>)
 800022c:	4a19      	ldr	r2, [pc, #100]	; (8000294 <endfiniloop+0x1e>)
 800022e:	4b1a      	ldr	r3, [pc, #104]	; (8000298 <endfiniloop+0x22>)

08000230 <dloop>:
 8000230:	429a      	cmp	r2, r3
 8000232:	bf3e      	ittt	cc
 8000234:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000238:	f842 0b04 	strcc.w	r0, [r2], #4
 800023c:	e7f8      	bcc.n	8000230 <dloop>
 800023e:	2000      	movs	r0, #0
 8000240:	4916      	ldr	r1, [pc, #88]	; (800029c <endfiniloop+0x26>)
 8000242:	4a17      	ldr	r2, [pc, #92]	; (80002a0 <endfiniloop+0x2a>)

08000244 <bloop>:
 8000244:	4291      	cmp	r1, r2
 8000246:	bf3c      	itt	cc
 8000248:	f841 0b04 	strcc.w	r0, [r1], #4
 800024c:	e7fa      	bcc.n	8000244 <bloop>
 800024e:	f000 f84f 	bl	80002f0 <__late_init>
 8000252:	4c14      	ldr	r4, [pc, #80]	; (80002a4 <endfiniloop+0x2e>)
 8000254:	4d14      	ldr	r5, [pc, #80]	; (80002a8 <endfiniloop+0x32>)

08000256 <initloop>:
 8000256:	42ac      	cmp	r4, r5
 8000258:	da03      	bge.n	8000262 <endinitloop>
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
 800025e:	4788      	blx	r1
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
 8000262:	f002 fe55 	bl	8002f10 <main>
 8000266:	4c11      	ldr	r4, [pc, #68]	; (80002ac <endfiniloop+0x36>)
 8000268:	4d11      	ldr	r5, [pc, #68]	; (80002b0 <endfiniloop+0x3a>)

0800026a <finiloop>:
 800026a:	42ac      	cmp	r4, r5
 800026c:	da03      	bge.n	8000276 <endfiniloop>
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000272:	4788      	blx	r1
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
 8000276:	f000 b843 	b.w	8000300 <__default_exit>
 800027a:	0000      	.short	0x0000
 800027c:	20000800 	.word	0x20000800
 8000280:	55555555 	.word	0x55555555
 8000284:	20000000 	.word	0x20000000
 8000288:	20000400 	.word	0x20000400
 800028c:	20000400 	.word	0x20000400
 8000290:	080031d0 	.word	0x080031d0
 8000294:	20000800 	.word	0x20000800
 8000298:	20000800 	.word	0x20000800
 800029c:	20000800 	.word	0x20000800
 80002a0:	20000d98 	.word	0x20000d98
 80002a4:	080001c0 	.word	0x080001c0
 80002a8:	080001c0 	.word	0x080001c0
 80002ac:	080001c0 	.word	0x080001c0
 80002b0:	080001c0 	.word	0x080001c0
	...

080002c0 <_port_switch>:
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002c4:	ed2d 8a10 	vpush	{s16-s31}
 80002c8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002cc:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 80002d0:	ecbd 8a10 	vpop	{s16-s31}
 80002d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d8 <_port_thread_start>:
 80002d8:	2300      	movs	r3, #0
 80002da:	f383 8811 	msr	BASEPRI, r3
 80002de:	4628      	mov	r0, r5
 80002e0:	47a0      	blx	r4
 80002e2:	2000      	movs	r0, #0
 80002e4:	f000 fd14 	bl	8000d10 <chThdExit>

080002e8 <_port_switch_from_isr>:
 80002e8:	f000 fbb2 	bl	8000a50 <chSchDoReschedule>

080002ec <_port_exit_from_isr>:
 80002ec:	df00      	svc	0
 80002ee:	e7fe      	b.n	80002ee <_port_exit_from_isr+0x2>

080002f0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80002f0:	4770      	bx	lr
 80002f2:	bf00      	nop
 80002f4:	f3af 8000 	nop.w
 80002f8:	f3af 8000 	nop.w
 80002fc:	f3af 8000 	nop.w

08000300 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8000300:	e7fe      	b.n	8000300 <__default_exit>
 8000302:	bf00      	nop
 8000304:	f3af 8000 	nop.w
 8000308:	f3af 8000 	nop.w
 800030c:	f3af 8000 	nop.w

08000310 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 8000310:	e7fe      	b.n	8000310 <_unhandled_exception>
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w

08000320 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000320:	b084      	sub	sp, #16
 8000322:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
 8000324:	9b01      	ldr	r3, [sp, #4]
 8000326:	f003 0307 	and.w	r3, r3, #7
 800032a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800032c:	4b0a      	ldr	r3, [pc, #40]	; (8000358 <NVIC_SetPriorityGrouping+0x38>)
 800032e:	68db      	ldr	r3, [r3, #12]
 8000330:	9302      	str	r3, [sp, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8000332:	9a02      	ldr	r2, [sp, #8]
 8000334:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000338:	4013      	ands	r3, r2
 800033a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 800033c:	9b03      	ldr	r3, [sp, #12]
 800033e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
 8000340:	9b02      	ldr	r3, [sp, #8]
 8000342:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8000344:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000348:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800034c:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800034e:	4a02      	ldr	r2, [pc, #8]	; (8000358 <NVIC_SetPriorityGrouping+0x38>)
 8000350:	9b02      	ldr	r3, [sp, #8]
 8000352:	60d3      	str	r3, [r2, #12]
}
 8000354:	b004      	add	sp, #16
 8000356:	4770      	bx	lr
 8000358:	e000ed00 	.word	0xe000ed00
 800035c:	f3af 8000 	nop.w

08000360 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000360:	b082      	sub	sp, #8
 8000362:	4603      	mov	r3, r0
 8000364:	9100      	str	r1, [sp, #0]
 8000366:	f88d 3007 	strb.w	r3, [sp, #7]
  if(IRQn < 0) {
 800036a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800036e:	2b00      	cmp	r3, #0
 8000370:	da0c      	bge.n	800038c <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000372:	490c      	ldr	r1, [pc, #48]	; (80003a4 <NVIC_SetPriority+0x44>)
 8000374:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000378:	f003 030f 	and.w	r3, r3, #15
 800037c:	3b04      	subs	r3, #4
 800037e:	9a00      	ldr	r2, [sp, #0]
 8000380:	b2d2      	uxtb	r2, r2
 8000382:	0112      	lsls	r2, r2, #4
 8000384:	b2d2      	uxtb	r2, r2
 8000386:	440b      	add	r3, r1
 8000388:	761a      	strb	r2, [r3, #24]
 800038a:	e009      	b.n	80003a0 <NVIC_SetPriority+0x40>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800038c:	4906      	ldr	r1, [pc, #24]	; (80003a8 <NVIC_SetPriority+0x48>)
 800038e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000392:	9a00      	ldr	r2, [sp, #0]
 8000394:	b2d2      	uxtb	r2, r2
 8000396:	0112      	lsls	r2, r2, #4
 8000398:	b2d2      	uxtb	r2, r2
 800039a:	440b      	add	r3, r1
 800039c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80003a0:	b002      	add	sp, #8
 80003a2:	4770      	bx	lr
 80003a4:	e000ed00 	.word	0xe000ed00
 80003a8:	e000e100 	.word	0xe000e100
 80003ac:	f3af 8000 	nop.w

080003b0 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 80003b0:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80003b2:	4b0e      	ldr	r3, [pc, #56]	; (80003ec <port_init+0x3c>)
 80003b4:	2200      	movs	r2, #0
 80003b6:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 80003b8:	2003      	movs	r0, #3
 80003ba:	f7ff ffb1 	bl	8000320 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80003be:	4a0c      	ldr	r2, [pc, #48]	; (80003f0 <port_init+0x40>)
 80003c0:	4b0b      	ldr	r3, [pc, #44]	; (80003f0 <port_init+0x40>)
 80003c2:	68db      	ldr	r3, [r3, #12]
 80003c4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80003c8:	60d3      	str	r3, [r2, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80003ca:	4a0a      	ldr	r2, [pc, #40]	; (80003f4 <port_init+0x44>)
 80003cc:	4b09      	ldr	r3, [pc, #36]	; (80003f4 <port_init+0x44>)
 80003ce:	681b      	ldr	r3, [r3, #0]
 80003d0:	f043 0301 	orr.w	r3, r3, #1
 80003d4:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 80003d6:	f06f 0004 	mvn.w	r0, #4
 80003da:	2101      	movs	r1, #1
 80003dc:	f7ff ffc0 	bl	8000360 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80003e0:	f06f 0001 	mvn.w	r0, #1
 80003e4:	2102      	movs	r1, #2
 80003e6:	f7ff ffbb 	bl	8000360 <NVIC_SetPriority>
}
 80003ea:	bd08      	pop	{r3, pc}
 80003ec:	e000ed00 	.word	0xe000ed00
 80003f0:	e000edf0 	.word	0xe000edf0
 80003f4:	e0001000 	.word	0xe0001000
 80003f8:	f3af 8000 	nop.w
 80003fc:	f3af 8000 	nop.w

08000400 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000400:	b082      	sub	sp, #8
 8000402:	2320      	movs	r3, #32
 8000404:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000406:	9b01      	ldr	r3, [sp, #4]
 8000408:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800040c:	b002      	add	sp, #8
 800040e:	4770      	bx	lr

08000410 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000410:	b082      	sub	sp, #8
 8000412:	2300      	movs	r3, #0
 8000414:	9301      	str	r3, [sp, #4]
 8000416:	9b01      	ldr	r3, [sp, #4]
 8000418:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800041c:	b002      	add	sp, #8
 800041e:	4770      	bx	lr

08000420 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000420:	b508      	push	{r3, lr}

  port_lock();
 8000422:	f7ff ffed 	bl	8000400 <port_lock>
}
 8000426:	bd08      	pop	{r3, pc}
 8000428:	f3af 8000 	nop.w
 800042c:	f3af 8000 	nop.w

08000430 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000430:	b508      	push	{r3, lr}

  port_unlock();
 8000432:	f7ff ffed 	bl	8000410 <port_unlock>
}
 8000436:	bd08      	pop	{r3, pc}
 8000438:	f3af 8000 	nop.w
 800043c:	f3af 8000 	nop.w

08000440 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000440:	b082      	sub	sp, #8
 8000442:	2300      	movs	r3, #0
 8000444:	9301      	str	r3, [sp, #4]
 8000446:	9b01      	ldr	r3, [sp, #4]
 8000448:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800044c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800044e:	b002      	add	sp, #8
 8000450:	4770      	bx	lr
 8000452:	bf00      	nop
 8000454:	f3af 8000 	nop.w
 8000458:	f3af 8000 	nop.w
 800045c:	f3af 8000 	nop.w

08000460 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000460:	4770      	bx	lr
 8000462:	bf00      	nop
 8000464:	f3af 8000 	nop.w
 8000468:	f3af 8000 	nop.w
 800046c:	f3af 8000 	nop.w

08000470 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8000470:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8000472:	f7ff ffe5 	bl	8000440 <port_enable>
}
 8000476:	bd08      	pop	{r3, pc}
 8000478:	f3af 8000 	nop.w
 800047c:	f3af 8000 	nop.w

08000480 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000480:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000482:	f7ff ffcd 	bl	8000420 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000486:	bd08      	pop	{r3, pc}
 8000488:	f3af 8000 	nop.w
 800048c:	f3af 8000 	nop.w

08000490 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000490:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000492:	f7ff ffcd 	bl	8000430 <port_unlock_from_isr>
}
 8000496:	bd08      	pop	{r3, pc}
 8000498:	f3af 8000 	nop.w
 800049c:	f3af 8000 	nop.w

080004a0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80004a0:	b500      	push	{lr}
 80004a2:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80004a4:	4b18      	ldr	r3, [pc, #96]	; (8000508 <chVTDoTickI+0x68>)
 80004a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80004a8:	3301      	adds	r3, #1
 80004aa:	4a17      	ldr	r2, [pc, #92]	; (8000508 <chVTDoTickI+0x68>)
 80004ac:	6293      	str	r3, [r2, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80004ae:	4b16      	ldr	r3, [pc, #88]	; (8000508 <chVTDoTickI+0x68>)
 80004b0:	69db      	ldr	r3, [r3, #28]
 80004b2:	4a16      	ldr	r2, [pc, #88]	; (800050c <chVTDoTickI+0x6c>)
 80004b4:	4293      	cmp	r3, r2
 80004b6:	d024      	beq.n	8000502 <chVTDoTickI+0x62>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 80004b8:	4b13      	ldr	r3, [pc, #76]	; (8000508 <chVTDoTickI+0x68>)
 80004ba:	69db      	ldr	r3, [r3, #28]
 80004bc:	689a      	ldr	r2, [r3, #8]
 80004be:	3a01      	subs	r2, #1
 80004c0:	609a      	str	r2, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 80004c2:	e019      	b.n	80004f8 <chVTDoTickI+0x58>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 80004c4:	4b10      	ldr	r3, [pc, #64]	; (8000508 <chVTDoTickI+0x68>)
 80004c6:	69db      	ldr	r3, [r3, #28]
 80004c8:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 80004ca:	9b01      	ldr	r3, [sp, #4]
 80004cc:	68db      	ldr	r3, [r3, #12]
 80004ce:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 80004d0:	9b01      	ldr	r3, [sp, #4]
 80004d2:	2200      	movs	r2, #0
 80004d4:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80004d6:	9b01      	ldr	r3, [sp, #4]
 80004d8:	681b      	ldr	r3, [r3, #0]
 80004da:	4a0c      	ldr	r2, [pc, #48]	; (800050c <chVTDoTickI+0x6c>)
 80004dc:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 80004de:	9b01      	ldr	r3, [sp, #4]
 80004e0:	681b      	ldr	r3, [r3, #0]
 80004e2:	4a09      	ldr	r2, [pc, #36]	; (8000508 <chVTDoTickI+0x68>)
 80004e4:	61d3      	str	r3, [r2, #28]
      chSysUnlockFromISR();
 80004e6:	f7ff ffd3 	bl	8000490 <chSysUnlockFromISR>
      fn(vtp->vt_par);
 80004ea:	9b01      	ldr	r3, [sp, #4]
 80004ec:	691a      	ldr	r2, [r3, #16]
 80004ee:	9b00      	ldr	r3, [sp, #0]
 80004f0:	4610      	mov	r0, r2
 80004f2:	4798      	blx	r3
      chSysLockFromISR();
 80004f4:	f7ff ffc4 	bl	8000480 <chSysLockFromISR>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 80004f8:	4b03      	ldr	r3, [pc, #12]	; (8000508 <chVTDoTickI+0x68>)
 80004fa:	69db      	ldr	r3, [r3, #28]
 80004fc:	689b      	ldr	r3, [r3, #8]
 80004fe:	2b00      	cmp	r3, #0
 8000500:	d0e0      	beq.n	80004c4 <chVTDoTickI+0x24>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000502:	b003      	add	sp, #12
 8000504:	f85d fb04 	ldr.w	pc, [sp], #4
 8000508:	20000800 	.word	0x20000800
 800050c:	2000081c 	.word	0x2000081c

08000510 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000510:	b500      	push	{lr}
 8000512:	b083      	sub	sp, #12
 8000514:	9001      	str	r0, [sp, #4]

  (void)p;
  chRegSetThreadName("idle");
 8000516:	4b03      	ldr	r3, [pc, #12]	; (8000524 <_idle_thread+0x14>)
 8000518:	699b      	ldr	r3, [r3, #24]
 800051a:	4a03      	ldr	r2, [pc, #12]	; (8000528 <_idle_thread+0x18>)
 800051c:	619a      	str	r2, [r3, #24]
  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 800051e:	f7ff ff9f 	bl	8000460 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
 8000522:	e7fc      	b.n	800051e <_idle_thread+0xe>
 8000524:	20000800 	.word	0x20000800
 8000528:	08002f90 	.word	0x08002f90
 800052c:	f3af 8000 	nop.w

08000530 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000530:	b500      	push	{lr}
 8000532:	b083      	sub	sp, #12
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8000534:	f7ff ff3c 	bl	80003b0 <port_init>
  _scheduler_init();
 8000538:	f000 f93a 	bl	80007b0 <_scheduler_init>
  _vt_init();
 800053c:	f000 f838 	bl	80005b0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8000540:	f000 fcbe 	bl	8000ec0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8000544:	f001 f83c 	bl	80015c0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8000548:	f001 f88a 	bl	8001660 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800054c:	480e      	ldr	r0, [pc, #56]	; (8000588 <chSysInit+0x58>)
 800054e:	2140      	movs	r1, #64	; 0x40
 8000550:	f000 fb46 	bl	8000be0 <_thread_init>
 8000554:	4602      	mov	r2, r0
 8000556:	4b0d      	ldr	r3, [pc, #52]	; (800058c <chSysInit+0x5c>)
 8000558:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800055a:	4b0c      	ldr	r3, [pc, #48]	; (800058c <chSysInit+0x5c>)
 800055c:	699b      	ldr	r3, [r3, #24]
 800055e:	2201      	movs	r2, #1
 8000560:	771a      	strb	r2, [r3, #28]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 8000562:	f7ff ff85 	bl	8000470 <chSysEnable>

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000566:	4b09      	ldr	r3, [pc, #36]	; (800058c <chSysInit+0x5c>)
 8000568:	699b      	ldr	r3, [r3, #24]
 800056a:	4a09      	ldr	r2, [pc, #36]	; (8000590 <chSysInit+0x60>)
 800056c:	619a      	str	r2, [r3, #24]

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  (void) chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa),
 800056e:	2300      	movs	r3, #0
 8000570:	9300      	str	r3, [sp, #0]
 8000572:	4808      	ldr	r0, [pc, #32]	; (8000594 <chSysInit+0x64>)
 8000574:	f44f 71b0 	mov.w	r1, #352	; 0x160
 8000578:	2201      	movs	r2, #1
 800057a:	4b07      	ldr	r3, [pc, #28]	; (8000598 <chSysInit+0x68>)
 800057c:	f000 fb98 	bl	8000cb0 <chThdCreateStatic>
                           IDLEPRIO, (tfunc_t)_idle_thread, NULL);
#endif
}
 8000580:	b003      	add	sp, #12
 8000582:	f85d fb04 	ldr.w	pc, [sp], #4
 8000586:	bf00      	nop
 8000588:	20000830 	.word	0x20000830
 800058c:	20000800 	.word	0x20000800
 8000590:	08002fc0 	.word	0x08002fc0
 8000594:	20000878 	.word	0x20000878
 8000598:	08000511 	.word	0x08000511
 800059c:	f3af 8000 	nop.w

080005a0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80005a0:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 80005a2:	f7ff ff7d 	bl	80004a0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80005a6:	bd08      	pop	{r3, pc}
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80005b0:	4b06      	ldr	r3, [pc, #24]	; (80005cc <_vt_init+0x1c>)
 80005b2:	4a07      	ldr	r2, [pc, #28]	; (80005d0 <_vt_init+0x20>)
 80005b4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80005b6:	4b05      	ldr	r3, [pc, #20]	; (80005cc <_vt_init+0x1c>)
 80005b8:	4a05      	ldr	r2, [pc, #20]	; (80005d0 <_vt_init+0x20>)
 80005ba:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 80005bc:	4b03      	ldr	r3, [pc, #12]	; (80005cc <_vt_init+0x1c>)
 80005be:	f04f 32ff 	mov.w	r2, #4294967295
 80005c2:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 80005c4:	4b01      	ldr	r3, [pc, #4]	; (80005cc <_vt_init+0x1c>)
 80005c6:	2200      	movs	r2, #0
 80005c8:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80005ca:	4770      	bx	lr
 80005cc:	20000800 	.word	0x20000800
 80005d0:	2000081c 	.word	0x2000081c
 80005d4:	f3af 8000 	nop.w
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80005e0:	b086      	sub	sp, #24
 80005e2:	9003      	str	r0, [sp, #12]
 80005e4:	9102      	str	r1, [sp, #8]
 80005e6:	9201      	str	r2, [sp, #4]
 80005e8:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80005ea:	9b03      	ldr	r3, [sp, #12]
 80005ec:	9a00      	ldr	r2, [sp, #0]
 80005ee:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80005f0:	9b03      	ldr	r3, [sp, #12]
 80005f2:	9a01      	ldr	r2, [sp, #4]
 80005f4:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 80005f6:	9b02      	ldr	r3, [sp, #8]
 80005f8:	9304      	str	r3, [sp, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 80005fa:	4b17      	ldr	r3, [pc, #92]	; (8000658 <chVTDoSetI+0x78>)
 80005fc:	69db      	ldr	r3, [r3, #28]
 80005fe:	9305      	str	r3, [sp, #20]
  while (p->vt_delta < delta) {
 8000600:	e007      	b.n	8000612 <chVTDoSetI+0x32>
    delta -= p->vt_delta;
 8000602:	9b05      	ldr	r3, [sp, #20]
 8000604:	689b      	ldr	r3, [r3, #8]
 8000606:	9a04      	ldr	r2, [sp, #16]
 8000608:	1ad3      	subs	r3, r2, r3
 800060a:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 800060c:	9b05      	ldr	r3, [sp, #20]
 800060e:	681b      	ldr	r3, [r3, #0]
 8000610:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000612:	9b05      	ldr	r3, [sp, #20]
 8000614:	689a      	ldr	r2, [r3, #8]
 8000616:	9b04      	ldr	r3, [sp, #16]
 8000618:	429a      	cmp	r2, r3
 800061a:	d3f2      	bcc.n	8000602 <chVTDoSetI+0x22>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800061c:	9b03      	ldr	r3, [sp, #12]
 800061e:	9a05      	ldr	r2, [sp, #20]
 8000620:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000622:	9b03      	ldr	r3, [sp, #12]
 8000624:	681b      	ldr	r3, [r3, #0]
 8000626:	685a      	ldr	r2, [r3, #4]
 8000628:	9b03      	ldr	r3, [sp, #12]
 800062a:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 800062c:	9b03      	ldr	r3, [sp, #12]
 800062e:	685b      	ldr	r3, [r3, #4]
 8000630:	9a03      	ldr	r2, [sp, #12]
 8000632:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8000634:	9b05      	ldr	r3, [sp, #20]
 8000636:	9a03      	ldr	r2, [sp, #12]
 8000638:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 800063a:	9b03      	ldr	r3, [sp, #12]
 800063c:	9a04      	ldr	r2, [sp, #16]
 800063e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000640:	9b05      	ldr	r3, [sp, #20]
 8000642:	689a      	ldr	r2, [r3, #8]
 8000644:	9b04      	ldr	r3, [sp, #16]
 8000646:	1ad2      	subs	r2, r2, r3
 8000648:	9b05      	ldr	r3, [sp, #20]
 800064a:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800064c:	4b02      	ldr	r3, [pc, #8]	; (8000658 <chVTDoSetI+0x78>)
 800064e:	f04f 32ff 	mov.w	r2, #4294967295
 8000652:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000654:	b006      	add	sp, #24
 8000656:	4770      	bx	lr
 8000658:	20000800 	.word	0x20000800
 800065c:	f3af 8000 	nop.w

08000660 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000660:	b082      	sub	sp, #8
 8000662:	9001      	str	r0, [sp, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000664:	9b01      	ldr	r3, [sp, #4]
 8000666:	681b      	ldr	r3, [r3, #0]
 8000668:	9a01      	ldr	r2, [sp, #4]
 800066a:	6812      	ldr	r2, [r2, #0]
 800066c:	6891      	ldr	r1, [r2, #8]
 800066e:	9a01      	ldr	r2, [sp, #4]
 8000670:	6892      	ldr	r2, [r2, #8]
 8000672:	440a      	add	r2, r1
 8000674:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000676:	9b01      	ldr	r3, [sp, #4]
 8000678:	685b      	ldr	r3, [r3, #4]
 800067a:	9a01      	ldr	r2, [sp, #4]
 800067c:	6812      	ldr	r2, [r2, #0]
 800067e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000680:	9b01      	ldr	r3, [sp, #4]
 8000682:	681b      	ldr	r3, [r3, #0]
 8000684:	9a01      	ldr	r2, [sp, #4]
 8000686:	6852      	ldr	r2, [r2, #4]
 8000688:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 800068a:	9b01      	ldr	r3, [sp, #4]
 800068c:	2200      	movs	r2, #0
 800068e:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000690:	4b02      	ldr	r3, [pc, #8]	; (800069c <chVTDoResetI+0x3c>)
 8000692:	f04f 32ff 	mov.w	r2, #4294967295
 8000696:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000698:	b002      	add	sp, #8
 800069a:	4770      	bx	lr
 800069c:	20000800 	.word	0x20000800

080006a0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80006a0:	b082      	sub	sp, #8
 80006a2:	2320      	movs	r3, #32
 80006a4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80006a6:	9b01      	ldr	r3, [sp, #4]
 80006a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80006ac:	b002      	add	sp, #8
 80006ae:	4770      	bx	lr

080006b0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80006b0:	b082      	sub	sp, #8
 80006b2:	2300      	movs	r3, #0
 80006b4:	9301      	str	r3, [sp, #4]
 80006b6:	9b01      	ldr	r3, [sp, #4]
 80006b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80006bc:	b002      	add	sp, #8
 80006be:	4770      	bx	lr

080006c0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80006c0:	b508      	push	{r3, lr}

  port_lock();
 80006c2:	f7ff ffed 	bl	80006a0 <port_lock>
}
 80006c6:	bd08      	pop	{r3, pc}
 80006c8:	f3af 8000 	nop.w
 80006cc:	f3af 8000 	nop.w

080006d0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80006d0:	b508      	push	{r3, lr}

  port_unlock();
 80006d2:	f7ff ffed 	bl	80006b0 <port_unlock>
}
 80006d6:	bd08      	pop	{r3, pc}
 80006d8:	f3af 8000 	nop.w
 80006dc:	f3af 8000 	nop.w

080006e0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80006e0:	b082      	sub	sp, #8
 80006e2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80006e4:	9b01      	ldr	r3, [sp, #4]
 80006e6:	9a01      	ldr	r2, [sp, #4]
 80006e8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80006ea:	9b01      	ldr	r3, [sp, #4]
 80006ec:	9a01      	ldr	r2, [sp, #4]
 80006ee:	605a      	str	r2, [r3, #4]
}
 80006f0:	b002      	add	sp, #8
 80006f2:	4770      	bx	lr
 80006f4:	f3af 8000 	nop.w
 80006f8:	f3af 8000 	nop.w
 80006fc:	f3af 8000 	nop.w

08000700 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000700:	b084      	sub	sp, #16
 8000702:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000704:	9b01      	ldr	r3, [sp, #4]
 8000706:	681b      	ldr	r3, [r3, #0]
 8000708:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800070a:	9b03      	ldr	r3, [sp, #12]
 800070c:	681a      	ldr	r2, [r3, #0]
 800070e:	9b01      	ldr	r3, [sp, #4]
 8000710:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000712:	9b01      	ldr	r3, [sp, #4]
 8000714:	681b      	ldr	r3, [r3, #0]
 8000716:	9a01      	ldr	r2, [sp, #4]
 8000718:	605a      	str	r2, [r3, #4]

  return tp;
 800071a:	9b03      	ldr	r3, [sp, #12]
}
 800071c:	4618      	mov	r0, r3
 800071e:	b004      	add	sp, #16
 8000720:	4770      	bx	lr
 8000722:	bf00      	nop
 8000724:	f3af 8000 	nop.w
 8000728:	f3af 8000 	nop.w
 800072c:	f3af 8000 	nop.w

08000730 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000730:	b082      	sub	sp, #8
 8000732:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8000734:	9b01      	ldr	r3, [sp, #4]
 8000736:	685b      	ldr	r3, [r3, #4]
 8000738:	9a01      	ldr	r2, [sp, #4]
 800073a:	6812      	ldr	r2, [r2, #0]
 800073c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800073e:	9b01      	ldr	r3, [sp, #4]
 8000740:	681b      	ldr	r3, [r3, #0]
 8000742:	9a01      	ldr	r2, [sp, #4]
 8000744:	6852      	ldr	r2, [r2, #4]
 8000746:	605a      	str	r2, [r3, #4]

  return tp;
 8000748:	9b01      	ldr	r3, [sp, #4]
}
 800074a:	4618      	mov	r0, r3
 800074c:	b002      	add	sp, #8
 800074e:	4770      	bx	lr

08000750 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000750:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000752:	f7ff ffb5 	bl	80006c0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000756:	bd08      	pop	{r3, pc}
 8000758:	f3af 8000 	nop.w
 800075c:	f3af 8000 	nop.w

08000760 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000760:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000762:	f7ff ffb5 	bl	80006d0 <port_unlock_from_isr>
}
 8000766:	bd08      	pop	{r3, pc}
 8000768:	f3af 8000 	nop.w
 800076c:	f3af 8000 	nop.w

08000770 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000770:	b082      	sub	sp, #8
 8000772:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8000774:	9b01      	ldr	r3, [sp, #4]
 8000776:	68db      	ldr	r3, [r3, #12]
 8000778:	2b00      	cmp	r3, #0
 800077a:	bf14      	ite	ne
 800077c:	2301      	movne	r3, #1
 800077e:	2300      	moveq	r3, #0
 8000780:	b2db      	uxtb	r3, r3
}
 8000782:	4618      	mov	r0, r3
 8000784:	b002      	add	sp, #8
 8000786:	4770      	bx	lr
 8000788:	f3af 8000 	nop.w
 800078c:	f3af 8000 	nop.w

08000790 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000790:	b082      	sub	sp, #8
 8000792:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8000794:	9b01      	ldr	r3, [sp, #4]
 8000796:	689b      	ldr	r3, [r3, #8]
 8000798:	1c5a      	adds	r2, r3, #1
 800079a:	9b01      	ldr	r3, [sp, #4]
 800079c:	609a      	str	r2, [r3, #8]
}
 800079e:	b002      	add	sp, #8
 80007a0:	4770      	bx	lr
 80007a2:	bf00      	nop
 80007a4:	f3af 8000 	nop.w
 80007a8:	f3af 8000 	nop.w
 80007ac:	f3af 8000 	nop.w

080007b0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 80007b0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 80007b2:	4806      	ldr	r0, [pc, #24]	; (80007cc <_scheduler_init+0x1c>)
 80007b4:	f7ff ff94 	bl	80006e0 <queue_init>
  ch.rlist.r_prio = NOPRIO;
 80007b8:	4b04      	ldr	r3, [pc, #16]	; (80007cc <_scheduler_init+0x1c>)
 80007ba:	2200      	movs	r2, #0
 80007bc:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80007be:	4b03      	ldr	r3, [pc, #12]	; (80007cc <_scheduler_init+0x1c>)
 80007c0:	4a02      	ldr	r2, [pc, #8]	; (80007cc <_scheduler_init+0x1c>)
 80007c2:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80007c4:	4b01      	ldr	r3, [pc, #4]	; (80007cc <_scheduler_init+0x1c>)
 80007c6:	4a01      	ldr	r2, [pc, #4]	; (80007cc <_scheduler_init+0x1c>)
 80007c8:	615a      	str	r2, [r3, #20]
#endif
}
 80007ca:	bd08      	pop	{r3, pc}
 80007cc:	20000800 	.word	0x20000800

080007d0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80007d0:	b084      	sub	sp, #16
 80007d2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80007d4:	9b01      	ldr	r3, [sp, #4]
 80007d6:	2200      	movs	r2, #0
 80007d8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80007da:	4b0e      	ldr	r3, [pc, #56]	; (8000814 <chSchReadyI+0x44>)
 80007dc:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 80007de:	9b03      	ldr	r3, [sp, #12]
 80007e0:	681b      	ldr	r3, [r3, #0]
 80007e2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 80007e4:	9b03      	ldr	r3, [sp, #12]
 80007e6:	689a      	ldr	r2, [r3, #8]
 80007e8:	9b01      	ldr	r3, [sp, #4]
 80007ea:	689b      	ldr	r3, [r3, #8]
 80007ec:	429a      	cmp	r2, r3
 80007ee:	d2f6      	bcs.n	80007de <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80007f0:	9b01      	ldr	r3, [sp, #4]
 80007f2:	9a03      	ldr	r2, [sp, #12]
 80007f4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80007f6:	9b03      	ldr	r3, [sp, #12]
 80007f8:	685a      	ldr	r2, [r3, #4]
 80007fa:	9b01      	ldr	r3, [sp, #4]
 80007fc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80007fe:	9b01      	ldr	r3, [sp, #4]
 8000800:	685b      	ldr	r3, [r3, #4]
 8000802:	9a01      	ldr	r2, [sp, #4]
 8000804:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8000806:	9b03      	ldr	r3, [sp, #12]
 8000808:	9a01      	ldr	r2, [sp, #4]
 800080a:	605a      	str	r2, [r3, #4]

  return tp;
 800080c:	9b01      	ldr	r3, [sp, #4]
}
 800080e:	4618      	mov	r0, r3
 8000810:	b004      	add	sp, #16
 8000812:	4770      	bx	lr
 8000814:	20000800 	.word	0x20000800
 8000818:	f3af 8000 	nop.w
 800081c:	f3af 8000 	nop.w

08000820 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000820:	b500      	push	{lr}
 8000822:	b085      	sub	sp, #20
 8000824:	4603      	mov	r3, r0
 8000826:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 800082a:	4b0d      	ldr	r3, [pc, #52]	; (8000860 <chSchGoSleepS+0x40>)
 800082c:	699b      	ldr	r3, [r3, #24]
 800082e:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8000830:	9b03      	ldr	r3, [sp, #12]
 8000832:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000836:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000838:	4809      	ldr	r0, [pc, #36]	; (8000860 <chSchGoSleepS+0x40>)
 800083a:	f7ff ff61 	bl	8000700 <queue_fifo_remove>
 800083e:	4602      	mov	r2, r0
 8000840:	4b07      	ldr	r3, [pc, #28]	; (8000860 <chSchGoSleepS+0x40>)
 8000842:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000844:	4b06      	ldr	r3, [pc, #24]	; (8000860 <chSchGoSleepS+0x40>)
 8000846:	699b      	ldr	r3, [r3, #24]
 8000848:	2201      	movs	r2, #1
 800084a:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 800084c:	4b04      	ldr	r3, [pc, #16]	; (8000860 <chSchGoSleepS+0x40>)
 800084e:	699b      	ldr	r3, [r3, #24]
 8000850:	4618      	mov	r0, r3
 8000852:	9903      	ldr	r1, [sp, #12]
 8000854:	f7ff fd34 	bl	80002c0 <_port_switch>
}
 8000858:	b005      	add	sp, #20
 800085a:	f85d fb04 	ldr.w	pc, [sp], #4
 800085e:	bf00      	nop
 8000860:	20000800 	.word	0x20000800
 8000864:	f3af 8000 	nop.w
 8000868:	f3af 8000 	nop.w
 800086c:	f3af 8000 	nop.w

08000870 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000870:	b500      	push	{lr}
 8000872:	b085      	sub	sp, #20
 8000874:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000876:	9b01      	ldr	r3, [sp, #4]
 8000878:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800087a:	f7ff ff69 	bl	8000750 <chSysLockFromISR>
  switch (tp->p_state) {
 800087e:	9b03      	ldr	r3, [sp, #12]
 8000880:	7f1b      	ldrb	r3, [r3, #28]
 8000882:	2b07      	cmp	r3, #7
 8000884:	d823      	bhi.n	80008ce <wakeup+0x5e>
 8000886:	a201      	add	r2, pc, #4	; (adr r2, 800088c <wakeup+0x1c>)
 8000888:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800088c:	080008ad 	.word	0x080008ad
 8000890:	080008cf 	.word	0x080008cf
 8000894:	080008cf 	.word	0x080008cf
 8000898:	080008b3 	.word	0x080008b3
 800089c:	080008c7 	.word	0x080008c7
 80008a0:	080008bd 	.word	0x080008bd
 80008a4:	080008cf 	.word	0x080008cf
 80008a8:	080008c7 	.word	0x080008c7
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 80008ac:	f7ff ff58 	bl	8000760 <chSysUnlockFromISR>
    return;
 80008b0:	e017      	b.n	80008e2 <wakeup+0x72>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80008b2:	9b03      	ldr	r3, [sp, #12]
 80008b4:	6a1b      	ldr	r3, [r3, #32]
 80008b6:	2200      	movs	r2, #0
 80008b8:	601a      	str	r2, [r3, #0]
    break;
 80008ba:	e009      	b.n	80008d0 <wakeup+0x60>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80008bc:	9b03      	ldr	r3, [sp, #12]
 80008be:	6a1b      	ldr	r3, [r3, #32]
 80008c0:	4618      	mov	r0, r3
 80008c2:	f7ff ff65 	bl	8000790 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 80008c6:	9803      	ldr	r0, [sp, #12]
 80008c8:	f7ff ff32 	bl	8000730 <queue_dequeue>
    break;
 80008cc:	e000      	b.n	80008d0 <wakeup+0x60>
  default:
    /* Any other state, nothing to do.*/
    break;
 80008ce:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80008d0:	9b03      	ldr	r3, [sp, #12]
 80008d2:	f04f 32ff 	mov.w	r2, #4294967295
 80008d6:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80008d8:	9803      	ldr	r0, [sp, #12]
 80008da:	f7ff ff79 	bl	80007d0 <chSchReadyI>
  chSysUnlockFromISR();
 80008de:	f7ff ff3f 	bl	8000760 <chSysUnlockFromISR>
}
 80008e2:	b005      	add	sp, #20
 80008e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80008e8:	f3af 8000 	nop.w
 80008ec:	f3af 8000 	nop.w

080008f0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80008f0:	b500      	push	{lr}
 80008f2:	b089      	sub	sp, #36	; 0x24
 80008f4:	4603      	mov	r3, r0
 80008f6:	9100      	str	r1, [sp, #0]
 80008f8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80008fc:	9b00      	ldr	r3, [sp, #0]
 80008fe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000902:	d019      	beq.n	8000938 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000904:	4b12      	ldr	r3, [pc, #72]	; (8000950 <chSchGoSleepTimeoutS+0x60>)
 8000906:	699b      	ldr	r3, [r3, #24]
 8000908:	aa03      	add	r2, sp, #12
 800090a:	4610      	mov	r0, r2
 800090c:	9900      	ldr	r1, [sp, #0]
 800090e:	4a11      	ldr	r2, [pc, #68]	; (8000954 <chSchGoSleepTimeoutS+0x64>)
 8000910:	f7ff fe66 	bl	80005e0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000914:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000918:	4618      	mov	r0, r3
 800091a:	f7ff ff81 	bl	8000820 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800091e:	ab03      	add	r3, sp, #12
 8000920:	4618      	mov	r0, r3
 8000922:	f7ff ff25 	bl	8000770 <chVTIsArmedI>
 8000926:	4603      	mov	r3, r0
 8000928:	2b00      	cmp	r3, #0
 800092a:	d004      	beq.n	8000936 <chSchGoSleepTimeoutS+0x46>
      chVTDoResetI(&vt);
 800092c:	ab03      	add	r3, sp, #12
 800092e:	4618      	mov	r0, r3
 8000930:	f7ff fe96 	bl	8000660 <chVTDoResetI>
 8000934:	e005      	b.n	8000942 <chSchGoSleepTimeoutS+0x52>
 8000936:	e004      	b.n	8000942 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000938:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800093c:	4618      	mov	r0, r3
 800093e:	f7ff ff6f 	bl	8000820 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000942:	4b03      	ldr	r3, [pc, #12]	; (8000950 <chSchGoSleepTimeoutS+0x60>)
 8000944:	699b      	ldr	r3, [r3, #24]
 8000946:	6a1b      	ldr	r3, [r3, #32]
}
 8000948:	4618      	mov	r0, r3
 800094a:	b009      	add	sp, #36	; 0x24
 800094c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000950:	20000800 	.word	0x20000800
 8000954:	08000871 	.word	0x08000871
 8000958:	f3af 8000 	nop.w
 800095c:	f3af 8000 	nop.w

08000960 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000960:	b500      	push	{lr}
 8000962:	b085      	sub	sp, #20
 8000964:	9001      	str	r0, [sp, #4]
 8000966:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000968:	9b01      	ldr	r3, [sp, #4]
 800096a:	9a00      	ldr	r2, [sp, #0]
 800096c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800096e:	9b01      	ldr	r3, [sp, #4]
 8000970:	689a      	ldr	r2, [r3, #8]
 8000972:	4b0e      	ldr	r3, [pc, #56]	; (80009ac <chSchWakeupS+0x4c>)
 8000974:	699b      	ldr	r3, [r3, #24]
 8000976:	689b      	ldr	r3, [r3, #8]
 8000978:	429a      	cmp	r2, r3
 800097a:	d803      	bhi.n	8000984 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 800097c:	9801      	ldr	r0, [sp, #4]
 800097e:	f7ff ff27 	bl	80007d0 <chSchReadyI>
 8000982:	e00f      	b.n	80009a4 <chSchWakeupS+0x44>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000984:	4b09      	ldr	r3, [pc, #36]	; (80009ac <chSchWakeupS+0x4c>)
 8000986:	699b      	ldr	r3, [r3, #24]
 8000988:	4618      	mov	r0, r3
 800098a:	f7ff ff21 	bl	80007d0 <chSchReadyI>
 800098e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8000990:	4a06      	ldr	r2, [pc, #24]	; (80009ac <chSchWakeupS+0x4c>)
 8000992:	9b01      	ldr	r3, [sp, #4]
 8000994:	6193      	str	r3, [r2, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000996:	9b01      	ldr	r3, [sp, #4]
 8000998:	2201      	movs	r2, #1
 800099a:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 800099c:	9801      	ldr	r0, [sp, #4]
 800099e:	9903      	ldr	r1, [sp, #12]
 80009a0:	f7ff fc8e 	bl	80002c0 <_port_switch>
  }
}
 80009a4:	b005      	add	sp, #20
 80009a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80009aa:	bf00      	nop
 80009ac:	20000800 	.word	0x20000800

080009b0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80009b0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80009b2:	4b09      	ldr	r3, [pc, #36]	; (80009d8 <chSchIsPreemptionRequired+0x28>)
 80009b4:	681b      	ldr	r3, [r3, #0]
 80009b6:	689b      	ldr	r3, [r3, #8]
 80009b8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 80009ba:	4b07      	ldr	r3, [pc, #28]	; (80009d8 <chSchIsPreemptionRequired+0x28>)
 80009bc:	699b      	ldr	r3, [r3, #24]
 80009be:	689b      	ldr	r3, [r3, #8]
 80009c0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80009c2:	9a01      	ldr	r2, [sp, #4]
 80009c4:	9b00      	ldr	r3, [sp, #0]
 80009c6:	429a      	cmp	r2, r3
 80009c8:	bf8c      	ite	hi
 80009ca:	2301      	movhi	r3, #1
 80009cc:	2300      	movls	r3, #0
 80009ce:	b2db      	uxtb	r3, r3
#endif
}
 80009d0:	4618      	mov	r0, r3
 80009d2:	b002      	add	sp, #8
 80009d4:	4770      	bx	lr
 80009d6:	bf00      	nop
 80009d8:	20000800 	.word	0x20000800
 80009dc:	f3af 8000 	nop.w

080009e0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80009e0:	b500      	push	{lr}
 80009e2:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 80009e4:	4b18      	ldr	r3, [pc, #96]	; (8000a48 <chSchDoRescheduleAhead+0x68>)
 80009e6:	699b      	ldr	r3, [r3, #24]
 80009e8:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80009ea:	4817      	ldr	r0, [pc, #92]	; (8000a48 <chSchDoRescheduleAhead+0x68>)
 80009ec:	f7ff fe88 	bl	8000700 <queue_fifo_remove>
 80009f0:	4602      	mov	r2, r0
 80009f2:	4b15      	ldr	r3, [pc, #84]	; (8000a48 <chSchDoRescheduleAhead+0x68>)
 80009f4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80009f6:	4b14      	ldr	r3, [pc, #80]	; (8000a48 <chSchDoRescheduleAhead+0x68>)
 80009f8:	699b      	ldr	r3, [r3, #24]
 80009fa:	2201      	movs	r2, #1
 80009fc:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 80009fe:	9b00      	ldr	r3, [sp, #0]
 8000a00:	2200      	movs	r2, #0
 8000a02:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000a04:	4b10      	ldr	r3, [pc, #64]	; (8000a48 <chSchDoRescheduleAhead+0x68>)
 8000a06:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8000a08:	9b01      	ldr	r3, [sp, #4]
 8000a0a:	681b      	ldr	r3, [r3, #0]
 8000a0c:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8000a0e:	9b01      	ldr	r3, [sp, #4]
 8000a10:	689a      	ldr	r2, [r3, #8]
 8000a12:	9b00      	ldr	r3, [sp, #0]
 8000a14:	689b      	ldr	r3, [r3, #8]
 8000a16:	429a      	cmp	r2, r3
 8000a18:	d8f6      	bhi.n	8000a08 <chSchDoRescheduleAhead+0x28>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000a1a:	9b00      	ldr	r3, [sp, #0]
 8000a1c:	9a01      	ldr	r2, [sp, #4]
 8000a1e:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8000a20:	9b01      	ldr	r3, [sp, #4]
 8000a22:	685a      	ldr	r2, [r3, #4]
 8000a24:	9b00      	ldr	r3, [sp, #0]
 8000a26:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8000a28:	9b00      	ldr	r3, [sp, #0]
 8000a2a:	685b      	ldr	r3, [r3, #4]
 8000a2c:	9a00      	ldr	r2, [sp, #0]
 8000a2e:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	9a00      	ldr	r2, [sp, #0]
 8000a34:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8000a36:	4b04      	ldr	r3, [pc, #16]	; (8000a48 <chSchDoRescheduleAhead+0x68>)
 8000a38:	699b      	ldr	r3, [r3, #24]
 8000a3a:	4618      	mov	r0, r3
 8000a3c:	9900      	ldr	r1, [sp, #0]
 8000a3e:	f7ff fc3f 	bl	80002c0 <_port_switch>
}
 8000a42:	b003      	add	sp, #12
 8000a44:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a48:	20000800 	.word	0x20000800
 8000a4c:	f3af 8000 	nop.w

08000a50 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000a50:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000a52:	f7ff ffc5 	bl	80009e0 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000a56:	bd08      	pop	{r3, pc}
 8000a58:	f3af 8000 	nop.w
 8000a5c:	f3af 8000 	nop.w

08000a60 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000a60:	b082      	sub	sp, #8
 8000a62:	2320      	movs	r3, #32
 8000a64:	9301      	str	r3, [sp, #4]
 8000a66:	9b01      	ldr	r3, [sp, #4]
 8000a68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a6c:	b002      	add	sp, #8
 8000a6e:	4770      	bx	lr

08000a70 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000a70:	b082      	sub	sp, #8
 8000a72:	2300      	movs	r3, #0
 8000a74:	9301      	str	r3, [sp, #4]
 8000a76:	9b01      	ldr	r3, [sp, #4]
 8000a78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a7c:	b002      	add	sp, #8
 8000a7e:	4770      	bx	lr

08000a80 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8000a80:	b082      	sub	sp, #8
 8000a82:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8000a84:	9b01      	ldr	r3, [sp, #4]
 8000a86:	9a01      	ldr	r2, [sp, #4]
 8000a88:	601a      	str	r2, [r3, #0]
}
 8000a8a:	b002      	add	sp, #8
 8000a8c:	4770      	bx	lr
 8000a8e:	bf00      	nop

08000a90 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8000a90:	b082      	sub	sp, #8
 8000a92:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000a94:	9b01      	ldr	r3, [sp, #4]
 8000a96:	681a      	ldr	r2, [r3, #0]
 8000a98:	9b01      	ldr	r3, [sp, #4]
 8000a9a:	429a      	cmp	r2, r3
 8000a9c:	bf14      	ite	ne
 8000a9e:	2301      	movne	r3, #1
 8000aa0:	2300      	moveq	r3, #0
 8000aa2:	b2db      	uxtb	r3, r3
}
 8000aa4:	4618      	mov	r0, r3
 8000aa6:	b002      	add	sp, #8
 8000aa8:	4770      	bx	lr
 8000aaa:	bf00      	nop
 8000aac:	f3af 8000 	nop.w

08000ab0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000ab0:	b082      	sub	sp, #8
 8000ab2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000ab4:	9b01      	ldr	r3, [sp, #4]
 8000ab6:	9a01      	ldr	r2, [sp, #4]
 8000ab8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000aba:	9b01      	ldr	r3, [sp, #4]
 8000abc:	9a01      	ldr	r2, [sp, #4]
 8000abe:	605a      	str	r2, [r3, #4]
}
 8000ac0:	b002      	add	sp, #8
 8000ac2:	4770      	bx	lr
 8000ac4:	f3af 8000 	nop.w
 8000ac8:	f3af 8000 	nop.w
 8000acc:	f3af 8000 	nop.w

08000ad0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8000ad0:	b082      	sub	sp, #8
 8000ad2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000ad4:	9b01      	ldr	r3, [sp, #4]
 8000ad6:	681a      	ldr	r2, [r3, #0]
 8000ad8:	9b01      	ldr	r3, [sp, #4]
 8000ada:	429a      	cmp	r2, r3
 8000adc:	bf14      	ite	ne
 8000ade:	2301      	movne	r3, #1
 8000ae0:	2300      	moveq	r3, #0
 8000ae2:	b2db      	uxtb	r3, r3
}
 8000ae4:	4618      	mov	r0, r3
 8000ae6:	b002      	add	sp, #8
 8000ae8:	4770      	bx	lr
 8000aea:	bf00      	nop
 8000aec:	f3af 8000 	nop.w

08000af0 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
 8000af0:	b084      	sub	sp, #16
 8000af2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8000af4:	9b01      	ldr	r3, [sp, #4]
 8000af6:	681b      	ldr	r3, [r3, #0]
 8000af8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8000afa:	9b03      	ldr	r3, [sp, #12]
 8000afc:	681a      	ldr	r2, [r3, #0]
 8000afe:	9b01      	ldr	r3, [sp, #4]
 8000b00:	601a      	str	r2, [r3, #0]

  return tp;
 8000b02:	9b03      	ldr	r3, [sp, #12]
}
 8000b04:	4618      	mov	r0, r3
 8000b06:	b004      	add	sp, #16
 8000b08:	4770      	bx	lr
 8000b0a:	bf00      	nop
 8000b0c:	f3af 8000 	nop.w

08000b10 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8000b10:	b082      	sub	sp, #8
 8000b12:	9001      	str	r0, [sp, #4]
 8000b14:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8000b16:	9b01      	ldr	r3, [sp, #4]
 8000b18:	9a00      	ldr	r2, [sp, #0]
 8000b1a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000b1c:	9b00      	ldr	r3, [sp, #0]
 8000b1e:	685a      	ldr	r2, [r3, #4]
 8000b20:	9b01      	ldr	r3, [sp, #4]
 8000b22:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000b24:	9b01      	ldr	r3, [sp, #4]
 8000b26:	685b      	ldr	r3, [r3, #4]
 8000b28:	9a01      	ldr	r2, [sp, #4]
 8000b2a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8000b2c:	9b00      	ldr	r3, [sp, #0]
 8000b2e:	9a01      	ldr	r2, [sp, #4]
 8000b30:	605a      	str	r2, [r3, #4]
}
 8000b32:	b002      	add	sp, #8
 8000b34:	4770      	bx	lr
 8000b36:	bf00      	nop
 8000b38:	f3af 8000 	nop.w
 8000b3c:	f3af 8000 	nop.w

08000b40 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000b40:	b084      	sub	sp, #16
 8000b42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000b44:	9b01      	ldr	r3, [sp, #4]
 8000b46:	681b      	ldr	r3, [r3, #0]
 8000b48:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000b4a:	9b03      	ldr	r3, [sp, #12]
 8000b4c:	681a      	ldr	r2, [r3, #0]
 8000b4e:	9b01      	ldr	r3, [sp, #4]
 8000b50:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000b52:	9b01      	ldr	r3, [sp, #4]
 8000b54:	681b      	ldr	r3, [r3, #0]
 8000b56:	9a01      	ldr	r2, [sp, #4]
 8000b58:	605a      	str	r2, [r3, #4]

  return tp;
 8000b5a:	9b03      	ldr	r3, [sp, #12]
}
 8000b5c:	4618      	mov	r0, r3
 8000b5e:	b004      	add	sp, #16
 8000b60:	4770      	bx	lr
 8000b62:	bf00      	nop
 8000b64:	f3af 8000 	nop.w
 8000b68:	f3af 8000 	nop.w
 8000b6c:	f3af 8000 	nop.w

08000b70 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8000b70:	b508      	push	{r3, lr}

  port_lock();
 8000b72:	f7ff ff75 	bl	8000a60 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000b76:	bd08      	pop	{r3, pc}
 8000b78:	f3af 8000 	nop.w
 8000b7c:	f3af 8000 	nop.w

08000b80 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000b80:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 8000b82:	f7ff ff75 	bl	8000a70 <port_unlock>
}
 8000b86:	bd08      	pop	{r3, pc}
 8000b88:	f3af 8000 	nop.w
 8000b8c:	f3af 8000 	nop.w

08000b90 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8000b90:	b500      	push	{lr}
 8000b92:	b083      	sub	sp, #12
 8000b94:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000b96:	2008      	movs	r0, #8
 8000b98:	9901      	ldr	r1, [sp, #4]
 8000b9a:	f7ff fea9 	bl	80008f0 <chSchGoSleepTimeoutS>
}
 8000b9e:	b003      	add	sp, #12
 8000ba0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ba4:	f3af 8000 	nop.w
 8000ba8:	f3af 8000 	nop.w
 8000bac:	f3af 8000 	nop.w

08000bb0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000bb0:	b500      	push	{lr}
 8000bb2:	b085      	sub	sp, #20
 8000bb4:	9001      	str	r0, [sp, #4]
 8000bb6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8000bb8:	9801      	ldr	r0, [sp, #4]
 8000bba:	f7ff ffc1 	bl	8000b40 <queue_fifo_remove>
 8000bbe:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000bc0:	9b03      	ldr	r3, [sp, #12]
 8000bc2:	9a00      	ldr	r2, [sp, #0]
 8000bc4:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000bc6:	9803      	ldr	r0, [sp, #12]
 8000bc8:	f7ff fe02 	bl	80007d0 <chSchReadyI>
}
 8000bcc:	b005      	add	sp, #20
 8000bce:	f85d fb04 	ldr.w	pc, [sp], #4
 8000bd2:	bf00      	nop
 8000bd4:	f3af 8000 	nop.w
 8000bd8:	f3af 8000 	nop.w
 8000bdc:	f3af 8000 	nop.w

08000be0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8000be0:	b500      	push	{lr}
 8000be2:	b083      	sub	sp, #12
 8000be4:	9001      	str	r0, [sp, #4]
 8000be6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8000be8:	9b01      	ldr	r3, [sp, #4]
 8000bea:	9a00      	ldr	r2, [sp, #0]
 8000bec:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 8000bee:	9b01      	ldr	r3, [sp, #4]
 8000bf0:	2202      	movs	r2, #2
 8000bf2:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000bf4:	9b01      	ldr	r3, [sp, #4]
 8000bf6:	2200      	movs	r2, #0
 8000bf8:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8000bfa:	9b01      	ldr	r3, [sp, #4]
 8000bfc:	9a00      	ldr	r2, [sp, #0]
 8000bfe:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8000c00:	9b01      	ldr	r3, [sp, #4]
 8000c02:	2200      	movs	r2, #0
 8000c04:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8000c06:	9b01      	ldr	r3, [sp, #4]
 8000c08:	2200      	movs	r2, #0
 8000c0a:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000c0c:	9b01      	ldr	r3, [sp, #4]
 8000c0e:	2201      	movs	r2, #1
 8000c10:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8000c12:	9b01      	ldr	r3, [sp, #4]
 8000c14:	2200      	movs	r2, #0
 8000c16:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8000c18:	9b01      	ldr	r3, [sp, #4]
 8000c1a:	4a0e      	ldr	r2, [pc, #56]	; (8000c54 <_thread_init+0x74>)
 8000c1c:	611a      	str	r2, [r3, #16]
 8000c1e:	4b0d      	ldr	r3, [pc, #52]	; (8000c54 <_thread_init+0x74>)
 8000c20:	695a      	ldr	r2, [r3, #20]
 8000c22:	9b01      	ldr	r3, [sp, #4]
 8000c24:	615a      	str	r2, [r3, #20]
 8000c26:	9b01      	ldr	r3, [sp, #4]
 8000c28:	695b      	ldr	r3, [r3, #20]
 8000c2a:	9a01      	ldr	r2, [sp, #4]
 8000c2c:	611a      	str	r2, [r3, #16]
 8000c2e:	4a09      	ldr	r2, [pc, #36]	; (8000c54 <_thread_init+0x74>)
 8000c30:	9b01      	ldr	r3, [sp, #4]
 8000c32:	6153      	str	r3, [r2, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8000c34:	9b01      	ldr	r3, [sp, #4]
 8000c36:	3324      	adds	r3, #36	; 0x24
 8000c38:	4618      	mov	r0, r3
 8000c3a:	f7ff ff21 	bl	8000a80 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8000c3e:	9b01      	ldr	r3, [sp, #4]
 8000c40:	3328      	adds	r3, #40	; 0x28
 8000c42:	4618      	mov	r0, r3
 8000c44:	f7ff ff34 	bl	8000ab0 <queue_init>
  chTMStartMeasurementX(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8000c48:	9b01      	ldr	r3, [sp, #4]
}
 8000c4a:	4618      	mov	r0, r3
 8000c4c:	b003      	add	sp, #12
 8000c4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c52:	bf00      	nop
 8000c54:	20000800 	.word	0x20000800
 8000c58:	f3af 8000 	nop.w
 8000c5c:	f3af 8000 	nop.w

08000c60 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8000c60:	b500      	push	{lr}
 8000c62:	b087      	sub	sp, #28
 8000c64:	9003      	str	r0, [sp, #12]
 8000c66:	9102      	str	r1, [sp, #8]
 8000c68:	9201      	str	r2, [sp, #4]
 8000c6a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 8000c6c:	9b03      	ldr	r3, [sp, #12]
 8000c6e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000c70:	9b02      	ldr	r3, [sp, #8]
 8000c72:	3b64      	subs	r3, #100	; 0x64
 8000c74:	9a03      	ldr	r2, [sp, #12]
 8000c76:	441a      	add	r2, r3
 8000c78:	9b05      	ldr	r3, [sp, #20]
 8000c7a:	60da      	str	r2, [r3, #12]
 8000c7c:	9b05      	ldr	r3, [sp, #20]
 8000c7e:	68db      	ldr	r3, [r3, #12]
 8000c80:	9a00      	ldr	r2, [sp, #0]
 8000c82:	641a      	str	r2, [r3, #64]	; 0x40
 8000c84:	9b05      	ldr	r3, [sp, #20]
 8000c86:	68db      	ldr	r3, [r3, #12]
 8000c88:	9a08      	ldr	r2, [sp, #32]
 8000c8a:	645a      	str	r2, [r3, #68]	; 0x44
 8000c8c:	9b05      	ldr	r3, [sp, #20]
 8000c8e:	68db      	ldr	r3, [r3, #12]
 8000c90:	4a05      	ldr	r2, [pc, #20]	; (8000ca8 <chThdCreateI+0x48>)
 8000c92:	661a      	str	r2, [r3, #96]	; 0x60

  return _thread_init(tp, prio);
 8000c94:	9805      	ldr	r0, [sp, #20]
 8000c96:	9901      	ldr	r1, [sp, #4]
 8000c98:	f7ff ffa2 	bl	8000be0 <_thread_init>
 8000c9c:	4603      	mov	r3, r0
}
 8000c9e:	4618      	mov	r0, r3
 8000ca0:	b007      	add	sp, #28
 8000ca2:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ca6:	bf00      	nop
 8000ca8:	080002d9 	.word	0x080002d9
 8000cac:	f3af 8000 	nop.w

08000cb0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000cb0:	b500      	push	{lr}
 8000cb2:	b089      	sub	sp, #36	; 0x24
 8000cb4:	9005      	str	r0, [sp, #20]
 8000cb6:	9104      	str	r1, [sp, #16]
 8000cb8:	9203      	str	r2, [sp, #12]
 8000cba:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8000cbc:	f7ff ff58 	bl	8000b70 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8000cc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000cc2:	9300      	str	r3, [sp, #0]
 8000cc4:	9805      	ldr	r0, [sp, #20]
 8000cc6:	9904      	ldr	r1, [sp, #16]
 8000cc8:	9a03      	ldr	r2, [sp, #12]
 8000cca:	9b02      	ldr	r3, [sp, #8]
 8000ccc:	f7ff ffc8 	bl	8000c60 <chThdCreateI>
 8000cd0:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8000cd2:	9807      	ldr	r0, [sp, #28]
 8000cd4:	2100      	movs	r1, #0
 8000cd6:	f7ff fe43 	bl	8000960 <chSchWakeupS>
  chSysUnlock();
 8000cda:	f7ff ff51 	bl	8000b80 <chSysUnlock>

  return tp;
 8000cde:	9b07      	ldr	r3, [sp, #28]
}
 8000ce0:	4618      	mov	r0, r3
 8000ce2:	b009      	add	sp, #36	; 0x24
 8000ce4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ce8:	f3af 8000 	nop.w
 8000cec:	f3af 8000 	nop.w

08000cf0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000cf0:	b500      	push	{lr}
 8000cf2:	b083      	sub	sp, #12
 8000cf4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8000cf6:	f7ff ff3b 	bl	8000b70 <chSysLock>
  chThdSleepS(time);
 8000cfa:	9801      	ldr	r0, [sp, #4]
 8000cfc:	f7ff ff48 	bl	8000b90 <chThdSleepS>
  chSysUnlock();
 8000d00:	f7ff ff3e 	bl	8000b80 <chSysUnlock>
}
 8000d04:	b003      	add	sp, #12
 8000d06:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d0a:	bf00      	nop
 8000d0c:	f3af 8000 	nop.w

08000d10 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8000d10:	b500      	push	{lr}
 8000d12:	b083      	sub	sp, #12
 8000d14:	9001      	str	r0, [sp, #4]

  chSysLock();
 8000d16:	f7ff ff2b 	bl	8000b70 <chSysLock>
  chThdExitS(msg);
 8000d1a:	9801      	ldr	r0, [sp, #4]
 8000d1c:	f000 f808 	bl	8000d30 <chThdExitS>
  /* The thread never returns here.*/
}
 8000d20:	b003      	add	sp, #12
 8000d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d26:	bf00      	nop
 8000d28:	f3af 8000 	nop.w
 8000d2c:	f3af 8000 	nop.w

08000d30 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000d30:	b500      	push	{lr}
 8000d32:	b085      	sub	sp, #20
 8000d34:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8000d36:	4b17      	ldr	r3, [pc, #92]	; (8000d94 <chThdExitS+0x64>)
 8000d38:	699b      	ldr	r3, [r3, #24]
 8000d3a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 8000d3c:	9b03      	ldr	r3, [sp, #12]
 8000d3e:	9a01      	ldr	r2, [sp, #4]
 8000d40:	621a      	str	r2, [r3, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000d42:	e008      	b.n	8000d56 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8000d44:	9b03      	ldr	r3, [sp, #12]
 8000d46:	3324      	adds	r3, #36	; 0x24
 8000d48:	4618      	mov	r0, r3
 8000d4a:	f7ff fed1 	bl	8000af0 <list_remove>
 8000d4e:	4603      	mov	r3, r0
 8000d50:	4618      	mov	r0, r3
 8000d52:	f7ff fd3d 	bl	80007d0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000d56:	9b03      	ldr	r3, [sp, #12]
 8000d58:	3324      	adds	r3, #36	; 0x24
 8000d5a:	4618      	mov	r0, r3
 8000d5c:	f7ff fe98 	bl	8000a90 <list_notempty>
 8000d60:	4603      	mov	r3, r0
 8000d62:	2b00      	cmp	r3, #0
 8000d64:	d1ee      	bne.n	8000d44 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8000d66:	9b03      	ldr	r3, [sp, #12]
 8000d68:	7f5b      	ldrb	r3, [r3, #29]
 8000d6a:	f003 0303 	and.w	r3, r3, #3
 8000d6e:	2b00      	cmp	r3, #0
 8000d70:	d109      	bne.n	8000d86 <chThdExitS+0x56>
    REG_REMOVE(tp);
 8000d72:	9b03      	ldr	r3, [sp, #12]
 8000d74:	695b      	ldr	r3, [r3, #20]
 8000d76:	9a03      	ldr	r2, [sp, #12]
 8000d78:	6912      	ldr	r2, [r2, #16]
 8000d7a:	611a      	str	r2, [r3, #16]
 8000d7c:	9b03      	ldr	r3, [sp, #12]
 8000d7e:	691b      	ldr	r3, [r3, #16]
 8000d80:	9a03      	ldr	r2, [sp, #12]
 8000d82:	6952      	ldr	r2, [r2, #20]
 8000d84:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000d86:	200f      	movs	r0, #15
 8000d88:	f7ff fd4a 	bl	8000820 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8000d8c:	b005      	add	sp, #20
 8000d8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d92:	bf00      	nop
 8000d94:	20000800 	.word	0x20000800
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8000da0:	b500      	push	{lr}
 8000da2:	b085      	sub	sp, #20
 8000da4:	9001      	str	r0, [sp, #4]
 8000da6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8000da8:	9b01      	ldr	r3, [sp, #4]
 8000daa:	681b      	ldr	r3, [r3, #0]
 8000dac:	2b00      	cmp	r3, #0
 8000dae:	d00b      	beq.n	8000dc8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8000db0:	9b01      	ldr	r3, [sp, #4]
 8000db2:	681b      	ldr	r3, [r3, #0]
 8000db4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8000db6:	9b01      	ldr	r3, [sp, #4]
 8000db8:	2200      	movs	r2, #0
 8000dba:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 8000dbc:	9b03      	ldr	r3, [sp, #12]
 8000dbe:	9a00      	ldr	r2, [sp, #0]
 8000dc0:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8000dc2:	9803      	ldr	r0, [sp, #12]
 8000dc4:	f7ff fd04 	bl	80007d0 <chSchReadyI>
  }
}
 8000dc8:	b005      	add	sp, #20
 8000dca:	f85d fb04 	ldr.w	pc, [sp], #4
 8000dce:	bf00      	nop

08000dd0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000dd0:	b500      	push	{lr}
 8000dd2:	b083      	sub	sp, #12
 8000dd4:	9001      	str	r0, [sp, #4]
 8000dd6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8000dd8:	9b00      	ldr	r3, [sp, #0]
 8000dda:	2b00      	cmp	r3, #0
 8000ddc:	d102      	bne.n	8000de4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 8000dde:	f04f 33ff 	mov.w	r3, #4294967295
 8000de2:	e00a      	b.n	8000dfa <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8000de4:	4b07      	ldr	r3, [pc, #28]	; (8000e04 <chThdEnqueueTimeoutS+0x34>)
 8000de6:	699b      	ldr	r3, [r3, #24]
 8000de8:	4618      	mov	r0, r3
 8000dea:	9901      	ldr	r1, [sp, #4]
 8000dec:	f7ff fe90 	bl	8000b10 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000df0:	2004      	movs	r0, #4
 8000df2:	9900      	ldr	r1, [sp, #0]
 8000df4:	f7ff fd7c 	bl	80008f0 <chSchGoSleepTimeoutS>
 8000df8:	4603      	mov	r3, r0
}
 8000dfa:	4618      	mov	r0, r3
 8000dfc:	b003      	add	sp, #12
 8000dfe:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e02:	bf00      	nop
 8000e04:	20000800 	.word	0x20000800
 8000e08:	f3af 8000 	nop.w
 8000e0c:	f3af 8000 	nop.w

08000e10 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000e10:	b500      	push	{lr}
 8000e12:	b083      	sub	sp, #12
 8000e14:	9001      	str	r0, [sp, #4]
 8000e16:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8000e18:	9801      	ldr	r0, [sp, #4]
 8000e1a:	f7ff fe59 	bl	8000ad0 <queue_notempty>
 8000e1e:	4603      	mov	r3, r0
 8000e20:	2b00      	cmp	r3, #0
 8000e22:	d003      	beq.n	8000e2c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8000e24:	9801      	ldr	r0, [sp, #4]
 8000e26:	9900      	ldr	r1, [sp, #0]
 8000e28:	f7ff fec2 	bl	8000bb0 <chThdDoDequeueNextI>
  }
}
 8000e2c:	b003      	add	sp, #12
 8000e2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e32:	bf00      	nop
 8000e34:	f3af 8000 	nop.w
 8000e38:	f3af 8000 	nop.w
 8000e3c:	f3af 8000 	nop.w

08000e40 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000e40:	4b01      	ldr	r3, [pc, #4]	; (8000e48 <port_rt_get_counter_value+0x8>)
 8000e42:	685b      	ldr	r3, [r3, #4]
}
 8000e44:	4618      	mov	r0, r3
 8000e46:	4770      	bx	lr
 8000e48:	e0001000 	.word	0xe0001000
 8000e4c:	f3af 8000 	nop.w

08000e50 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8000e50:	b084      	sub	sp, #16
 8000e52:	9003      	str	r0, [sp, #12]
 8000e54:	9102      	str	r1, [sp, #8]
 8000e56:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8000e58:	9b03      	ldr	r3, [sp, #12]
 8000e5a:	68db      	ldr	r3, [r3, #12]
 8000e5c:	1c5a      	adds	r2, r3, #1
 8000e5e:	9b03      	ldr	r3, [sp, #12]
 8000e60:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8000e62:	9b03      	ldr	r3, [sp, #12]
 8000e64:	689b      	ldr	r3, [r3, #8]
 8000e66:	9a02      	ldr	r2, [sp, #8]
 8000e68:	1ad2      	subs	r2, r2, r3
 8000e6a:	9b01      	ldr	r3, [sp, #4]
 8000e6c:	1ad2      	subs	r2, r2, r3
 8000e6e:	9b03      	ldr	r3, [sp, #12]
 8000e70:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000e72:	9b03      	ldr	r3, [sp, #12]
 8000e74:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8000e78:	9b03      	ldr	r3, [sp, #12]
 8000e7a:	689b      	ldr	r3, [r3, #8]
 8000e7c:	461a      	mov	r2, r3
 8000e7e:	f04f 0300 	mov.w	r3, #0
 8000e82:	1812      	adds	r2, r2, r0
 8000e84:	eb43 0301 	adc.w	r3, r3, r1
 8000e88:	9903      	ldr	r1, [sp, #12]
 8000e8a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8000e8e:	9b03      	ldr	r3, [sp, #12]
 8000e90:	689a      	ldr	r2, [r3, #8]
 8000e92:	9b03      	ldr	r3, [sp, #12]
 8000e94:	685b      	ldr	r3, [r3, #4]
 8000e96:	429a      	cmp	r2, r3
 8000e98:	d904      	bls.n	8000ea4 <tm_stop+0x54>
    tmp->worst = tmp->last;
 8000e9a:	9b03      	ldr	r3, [sp, #12]
 8000e9c:	689a      	ldr	r2, [r3, #8]
 8000e9e:	9b03      	ldr	r3, [sp, #12]
 8000ea0:	605a      	str	r2, [r3, #4]
 8000ea2:	e009      	b.n	8000eb8 <tm_stop+0x68>
  }
  else if (tmp->last < tmp->best) {
 8000ea4:	9b03      	ldr	r3, [sp, #12]
 8000ea6:	689a      	ldr	r2, [r3, #8]
 8000ea8:	9b03      	ldr	r3, [sp, #12]
 8000eaa:	681b      	ldr	r3, [r3, #0]
 8000eac:	429a      	cmp	r2, r3
 8000eae:	d203      	bcs.n	8000eb8 <tm_stop+0x68>
    tmp->best = tmp->last;
 8000eb0:	9b03      	ldr	r3, [sp, #12]
 8000eb2:	689a      	ldr	r2, [r3, #8]
 8000eb4:	9b03      	ldr	r3, [sp, #12]
 8000eb6:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
 8000eb8:	b004      	add	sp, #16
 8000eba:	4770      	bx	lr
 8000ebc:	f3af 8000 	nop.w

08000ec0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8000ec0:	b500      	push	{lr}
 8000ec2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000ec4:	4b0a      	ldr	r3, [pc, #40]	; (8000ef0 <_tm_init+0x30>)
 8000ec6:	2200      	movs	r2, #0
 8000ec8:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 8000eca:	466b      	mov	r3, sp
 8000ecc:	4618      	mov	r0, r3
 8000ece:	f000 f817 	bl	8000f00 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8000ed2:	466b      	mov	r3, sp
 8000ed4:	4618      	mov	r0, r3
 8000ed6:	f000 f82b 	bl	8000f30 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8000eda:	466b      	mov	r3, sp
 8000edc:	4618      	mov	r0, r3
 8000ede:	f000 f837 	bl	8000f50 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8000ee2:	9b02      	ldr	r3, [sp, #8]
 8000ee4:	4a02      	ldr	r2, [pc, #8]	; (8000ef0 <_tm_init+0x30>)
 8000ee6:	6753      	str	r3, [r2, #116]	; 0x74
}
 8000ee8:	b007      	add	sp, #28
 8000eea:	f85d fb04 	ldr.w	pc, [sp], #4
 8000eee:	bf00      	nop
 8000ef0:	20000800 	.word	0x20000800
 8000ef4:	f3af 8000 	nop.w
 8000ef8:	f3af 8000 	nop.w
 8000efc:	f3af 8000 	nop.w

08000f00 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8000f00:	b082      	sub	sp, #8
 8000f02:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8000f04:	9b01      	ldr	r3, [sp, #4]
 8000f06:	f04f 32ff 	mov.w	r2, #4294967295
 8000f0a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 8000f0c:	9b01      	ldr	r3, [sp, #4]
 8000f0e:	2200      	movs	r2, #0
 8000f10:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8000f12:	9b01      	ldr	r3, [sp, #4]
 8000f14:	2200      	movs	r2, #0
 8000f16:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8000f18:	9b01      	ldr	r3, [sp, #4]
 8000f1a:	2200      	movs	r2, #0
 8000f1c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8000f1e:	9901      	ldr	r1, [sp, #4]
 8000f20:	f04f 0200 	mov.w	r2, #0
 8000f24:	f04f 0300 	mov.w	r3, #0
 8000f28:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 8000f2c:	b002      	add	sp, #8
 8000f2e:	4770      	bx	lr

08000f30 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8000f30:	b500      	push	{lr}
 8000f32:	b083      	sub	sp, #12
 8000f34:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8000f36:	f7ff ff83 	bl	8000e40 <port_rt_get_counter_value>
 8000f3a:	4602      	mov	r2, r0
 8000f3c:	9b01      	ldr	r3, [sp, #4]
 8000f3e:	609a      	str	r2, [r3, #8]
}
 8000f40:	b003      	add	sp, #12
 8000f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f46:	bf00      	nop
 8000f48:	f3af 8000 	nop.w
 8000f4c:	f3af 8000 	nop.w

08000f50 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000f50:	b500      	push	{lr}
 8000f52:	b083      	sub	sp, #12
 8000f54:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000f56:	f7ff ff73 	bl	8000e40 <port_rt_get_counter_value>
 8000f5a:	4602      	mov	r2, r0
 8000f5c:	4b04      	ldr	r3, [pc, #16]	; (8000f70 <chTMStopMeasurementX+0x20>)
 8000f5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000f60:	9801      	ldr	r0, [sp, #4]
 8000f62:	4611      	mov	r1, r2
 8000f64:	461a      	mov	r2, r3
 8000f66:	f7ff ff73 	bl	8000e50 <tm_stop>
}
 8000f6a:	b003      	add	sp, #12
 8000f6c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f70:	20000800 	.word	0x20000800
 8000f74:	f3af 8000 	nop.w
 8000f78:	f3af 8000 	nop.w
 8000f7c:	f3af 8000 	nop.w

08000f80 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000f80:	b082      	sub	sp, #8
 8000f82:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000f84:	9b01      	ldr	r3, [sp, #4]
 8000f86:	9a01      	ldr	r2, [sp, #4]
 8000f88:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000f8a:	9b01      	ldr	r3, [sp, #4]
 8000f8c:	9a01      	ldr	r2, [sp, #4]
 8000f8e:	605a      	str	r2, [r3, #4]
}
 8000f90:	b002      	add	sp, #8
 8000f92:	4770      	bx	lr
 8000f94:	f3af 8000 	nop.w
 8000f98:	f3af 8000 	nop.w
 8000f9c:	f3af 8000 	nop.w

08000fa0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8000fa0:	b500      	push	{lr}
 8000fa2:	b083      	sub	sp, #12
 8000fa4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8000fa6:	9b01      	ldr	r3, [sp, #4]
 8000fa8:	4618      	mov	r0, r3
 8000faa:	f7ff ffe9 	bl	8000f80 <queue_init>
  mp->m_owner = NULL;
 8000fae:	9b01      	ldr	r3, [sp, #4]
 8000fb0:	2200      	movs	r2, #0
 8000fb2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8000fb4:	b003      	add	sp, #12
 8000fb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8000fba:	bf00      	nop
 8000fbc:	f3af 8000 	nop.w

08000fc0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000fc0:	b500      	push	{lr}
 8000fc2:	b085      	sub	sp, #20
 8000fc4:	9001      	str	r0, [sp, #4]
 8000fc6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000fc8:	9b01      	ldr	r3, [sp, #4]
 8000fca:	681b      	ldr	r3, [r3, #0]
 8000fcc:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000fce:	e01a      	b.n	8001006 <chEvtBroadcastFlagsI+0x46>
  /*lint -restore*/
    elp->el_flags |= flags;
 8000fd0:	9b03      	ldr	r3, [sp, #12]
 8000fd2:	68da      	ldr	r2, [r3, #12]
 8000fd4:	9b00      	ldr	r3, [sp, #0]
 8000fd6:	431a      	orrs	r2, r3
 8000fd8:	9b03      	ldr	r3, [sp, #12]
 8000fda:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000fdc:	9b00      	ldr	r3, [sp, #0]
 8000fde:	2b00      	cmp	r3, #0
 8000fe0:	d006      	beq.n	8000ff0 <chEvtBroadcastFlagsI+0x30>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8000fe2:	9b03      	ldr	r3, [sp, #12]
 8000fe4:	68da      	ldr	r2, [r3, #12]
 8000fe6:	9b03      	ldr	r3, [sp, #12]
 8000fe8:	691b      	ldr	r3, [r3, #16]
 8000fea:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000fec:	2b00      	cmp	r3, #0
 8000fee:	d007      	beq.n	8001000 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000ff0:	9b03      	ldr	r3, [sp, #12]
 8000ff2:	685a      	ldr	r2, [r3, #4]
 8000ff4:	9b03      	ldr	r3, [sp, #12]
 8000ff6:	689b      	ldr	r3, [r3, #8]
 8000ff8:	4610      	mov	r0, r2
 8000ffa:	4619      	mov	r1, r3
 8000ffc:	f000 f810 	bl	8001020 <chEvtSignalI>
    }
    elp = elp->el_next;
 8001000:	9b03      	ldr	r3, [sp, #12]
 8001002:	681b      	ldr	r3, [r3, #0]
 8001004:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001006:	9a03      	ldr	r2, [sp, #12]
 8001008:	9b01      	ldr	r3, [sp, #4]
 800100a:	429a      	cmp	r2, r3
 800100c:	d1e0      	bne.n	8000fd0 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 800100e:	b005      	add	sp, #20
 8001010:	f85d fb04 	ldr.w	pc, [sp], #4
 8001014:	f3af 8000 	nop.w
 8001018:	f3af 8000 	nop.w
 800101c:	f3af 8000 	nop.w

08001020 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8001020:	b500      	push	{lr}
 8001022:	b083      	sub	sp, #12
 8001024:	9001      	str	r0, [sp, #4]
 8001026:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001028:	9b01      	ldr	r3, [sp, #4]
 800102a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800102c:	9b00      	ldr	r3, [sp, #0]
 800102e:	431a      	orrs	r2, r3
 8001030:	9b01      	ldr	r3, [sp, #4]
 8001032:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001034:	9b01      	ldr	r3, [sp, #4]
 8001036:	7f1b      	ldrb	r3, [r3, #28]
 8001038:	2b0a      	cmp	r3, #10
 800103a:	d106      	bne.n	800104a <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800103c:	9b01      	ldr	r3, [sp, #4]
 800103e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001040:	9b01      	ldr	r3, [sp, #4]
 8001042:	6a1b      	ldr	r3, [r3, #32]
 8001044:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001046:	2b00      	cmp	r3, #0
 8001048:	d10c      	bne.n	8001064 <chEvtSignalI+0x44>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800104a:	9b01      	ldr	r3, [sp, #4]
 800104c:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800104e:	2b0b      	cmp	r3, #11
 8001050:	d10e      	bne.n	8001070 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001052:	9b01      	ldr	r3, [sp, #4]
 8001054:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001056:	9b01      	ldr	r3, [sp, #4]
 8001058:	6a1b      	ldr	r3, [r3, #32]
 800105a:	401a      	ands	r2, r3
 800105c:	9b01      	ldr	r3, [sp, #4]
 800105e:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001060:	429a      	cmp	r2, r3
 8001062:	d105      	bne.n	8001070 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001064:	9b01      	ldr	r3, [sp, #4]
 8001066:	2200      	movs	r2, #0
 8001068:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 800106a:	9801      	ldr	r0, [sp, #4]
 800106c:	f7ff fbb0 	bl	80007d0 <chSchReadyI>
  }
}
 8001070:	b003      	add	sp, #12
 8001072:	f85d fb04 	ldr.w	pc, [sp], #4
 8001076:	bf00      	nop
 8001078:	f3af 8000 	nop.w
 800107c:	f3af 8000 	nop.w

08001080 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001080:	b082      	sub	sp, #8
 8001082:	2320      	movs	r3, #32
 8001084:	9301      	str	r3, [sp, #4]
 8001086:	9b01      	ldr	r3, [sp, #4]
 8001088:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800108c:	b002      	add	sp, #8
 800108e:	4770      	bx	lr

08001090 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001090:	b082      	sub	sp, #8
 8001092:	2300      	movs	r3, #0
 8001094:	9301      	str	r3, [sp, #4]
 8001096:	9b01      	ldr	r3, [sp, #4]
 8001098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800109c:	b002      	add	sp, #8
 800109e:	4770      	bx	lr

080010a0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80010a0:	b082      	sub	sp, #8
 80010a2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80010a4:	9b01      	ldr	r3, [sp, #4]
 80010a6:	9a01      	ldr	r2, [sp, #4]
 80010a8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80010aa:	9b01      	ldr	r3, [sp, #4]
 80010ac:	9a01      	ldr	r2, [sp, #4]
 80010ae:	605a      	str	r2, [r3, #4]
}
 80010b0:	b002      	add	sp, #8
 80010b2:	4770      	bx	lr
 80010b4:	f3af 8000 	nop.w
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 80010c0:	b508      	push	{r3, lr}

  port_lock();
 80010c2:	f7ff ffdd 	bl	8001080 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80010c6:	bd08      	pop	{r3, pc}
 80010c8:	f3af 8000 	nop.w
 80010cc:	f3af 8000 	nop.w

080010d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80010d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 80010d2:	f7ff ffdd 	bl	8001090 <port_unlock>
}
 80010d6:	bd08      	pop	{r3, pc}
 80010d8:	f3af 8000 	nop.w
 80010dc:	f3af 8000 	nop.w

080010e0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80010e0:	b500      	push	{lr}
 80010e2:	b083      	sub	sp, #12
 80010e4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80010e6:	9801      	ldr	r0, [sp, #4]
 80010e8:	f7ff ffda 	bl	80010a0 <queue_init>
}
 80010ec:	b003      	add	sp, #12
 80010ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80010f2:	bf00      	nop
 80010f4:	f3af 8000 	nop.w
 80010f8:	f3af 8000 	nop.w
 80010fc:	f3af 8000 	nop.w

08001100 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8001100:	b082      	sub	sp, #8
 8001102:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8001104:	9b01      	ldr	r3, [sp, #4]
 8001106:	689b      	ldr	r3, [r3, #8]
 8001108:	2b00      	cmp	r3, #0
 800110a:	bf0c      	ite	eq
 800110c:	2301      	moveq	r3, #1
 800110e:	2300      	movne	r3, #0
 8001110:	b2db      	uxtb	r3, r3
}
 8001112:	4618      	mov	r0, r3
 8001114:	b002      	add	sp, #8
 8001116:	4770      	bx	lr
 8001118:	f3af 8000 	nop.w
 800111c:	f3af 8000 	nop.w

08001120 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8001120:	b082      	sub	sp, #8
 8001122:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	695a      	ldr	r2, [r3, #20]
 8001128:	9b01      	ldr	r3, [sp, #4]
 800112a:	699b      	ldr	r3, [r3, #24]
 800112c:	429a      	cmp	r2, r3
 800112e:	d105      	bne.n	800113c <chIQIsFullI+0x1c>
 8001130:	9b01      	ldr	r3, [sp, #4]
 8001132:	689b      	ldr	r3, [r3, #8]
 8001134:	2b00      	cmp	r3, #0
 8001136:	d001      	beq.n	800113c <chIQIsFullI+0x1c>
 8001138:	2301      	movs	r3, #1
 800113a:	e000      	b.n	800113e <chIQIsFullI+0x1e>
 800113c:	2300      	movs	r3, #0
 800113e:	f003 0301 	and.w	r3, r3, #1
 8001142:	b2db      	uxtb	r3, r3
}
 8001144:	4618      	mov	r0, r3
 8001146:	b002      	add	sp, #8
 8001148:	4770      	bx	lr
 800114a:	bf00      	nop
 800114c:	f3af 8000 	nop.w

08001150 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8001150:	b082      	sub	sp, #8
 8001152:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001154:	9b01      	ldr	r3, [sp, #4]
 8001156:	695a      	ldr	r2, [r3, #20]
 8001158:	9b01      	ldr	r3, [sp, #4]
 800115a:	699b      	ldr	r3, [r3, #24]
 800115c:	429a      	cmp	r2, r3
 800115e:	d105      	bne.n	800116c <chOQIsEmptyI+0x1c>
 8001160:	9b01      	ldr	r3, [sp, #4]
 8001162:	689b      	ldr	r3, [r3, #8]
 8001164:	2b00      	cmp	r3, #0
 8001166:	d001      	beq.n	800116c <chOQIsEmptyI+0x1c>
 8001168:	2301      	movs	r3, #1
 800116a:	e000      	b.n	800116e <chOQIsEmptyI+0x1e>
 800116c:	2300      	movs	r3, #0
 800116e:	f003 0301 	and.w	r3, r3, #1
 8001172:	b2db      	uxtb	r3, r3
}
 8001174:	4618      	mov	r0, r3
 8001176:	b002      	add	sp, #8
 8001178:	4770      	bx	lr
 800117a:	bf00      	nop
 800117c:	f3af 8000 	nop.w

08001180 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8001180:	b082      	sub	sp, #8
 8001182:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8001184:	9b01      	ldr	r3, [sp, #4]
 8001186:	689b      	ldr	r3, [r3, #8]
 8001188:	2b00      	cmp	r3, #0
 800118a:	bf0c      	ite	eq
 800118c:	2301      	moveq	r3, #1
 800118e:	2300      	movne	r3, #0
 8001190:	b2db      	uxtb	r3, r3
}
 8001192:	4618      	mov	r0, r3
 8001194:	b002      	add	sp, #8
 8001196:	4770      	bx	lr
 8001198:	f3af 8000 	nop.w
 800119c:	f3af 8000 	nop.w

080011a0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 80011a0:	b500      	push	{lr}
 80011a2:	b085      	sub	sp, #20
 80011a4:	9003      	str	r0, [sp, #12]
 80011a6:	9102      	str	r1, [sp, #8]
 80011a8:	9201      	str	r2, [sp, #4]
 80011aa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 80011ac:	9b03      	ldr	r3, [sp, #12]
 80011ae:	4618      	mov	r0, r3
 80011b0:	f7ff ff96 	bl	80010e0 <chThdQueueObjectInit>
  iqp->q_counter = 0;
 80011b4:	9b03      	ldr	r3, [sp, #12]
 80011b6:	2200      	movs	r2, #0
 80011b8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80011ba:	9b03      	ldr	r3, [sp, #12]
 80011bc:	9a02      	ldr	r2, [sp, #8]
 80011be:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80011c0:	9b03      	ldr	r3, [sp, #12]
 80011c2:	9a02      	ldr	r2, [sp, #8]
 80011c4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80011c6:	9b03      	ldr	r3, [sp, #12]
 80011c8:	9a02      	ldr	r2, [sp, #8]
 80011ca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80011cc:	9a02      	ldr	r2, [sp, #8]
 80011ce:	9b01      	ldr	r3, [sp, #4]
 80011d0:	441a      	add	r2, r3
 80011d2:	9b03      	ldr	r3, [sp, #12]
 80011d4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80011d6:	9b03      	ldr	r3, [sp, #12]
 80011d8:	9a00      	ldr	r2, [sp, #0]
 80011da:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80011dc:	9b03      	ldr	r3, [sp, #12]
 80011de:	9a06      	ldr	r2, [sp, #24]
 80011e0:	621a      	str	r2, [r3, #32]
}
 80011e2:	b005      	add	sp, #20
 80011e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80011e8:	f3af 8000 	nop.w
 80011ec:	f3af 8000 	nop.w

080011f0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 80011f0:	b500      	push	{lr}
 80011f2:	b083      	sub	sp, #12
 80011f4:	9001      	str	r0, [sp, #4]
 80011f6:	460b      	mov	r3, r1
 80011f8:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 80011fc:	9801      	ldr	r0, [sp, #4]
 80011fe:	f7ff ff8f 	bl	8001120 <chIQIsFullI>
 8001202:	4603      	mov	r3, r0
 8001204:	2b00      	cmp	r3, #0
 8001206:	d002      	beq.n	800120e <chIQPutI+0x1e>
    return Q_FULL;
 8001208:	f06f 0303 	mvn.w	r3, #3
 800120c:	e01c      	b.n	8001248 <chIQPutI+0x58>
  }

  iqp->q_counter++;
 800120e:	9b01      	ldr	r3, [sp, #4]
 8001210:	689b      	ldr	r3, [r3, #8]
 8001212:	1c5a      	adds	r2, r3, #1
 8001214:	9b01      	ldr	r3, [sp, #4]
 8001216:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8001218:	9b01      	ldr	r3, [sp, #4]
 800121a:	695b      	ldr	r3, [r3, #20]
 800121c:	1c59      	adds	r1, r3, #1
 800121e:	9a01      	ldr	r2, [sp, #4]
 8001220:	6151      	str	r1, [r2, #20]
 8001222:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001226:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8001228:	9b01      	ldr	r3, [sp, #4]
 800122a:	695a      	ldr	r2, [r3, #20]
 800122c:	9b01      	ldr	r3, [sp, #4]
 800122e:	691b      	ldr	r3, [r3, #16]
 8001230:	429a      	cmp	r2, r3
 8001232:	d303      	bcc.n	800123c <chIQPutI+0x4c>
    iqp->q_wrptr = iqp->q_buffer;
 8001234:	9b01      	ldr	r3, [sp, #4]
 8001236:	68da      	ldr	r2, [r3, #12]
 8001238:	9b01      	ldr	r3, [sp, #4]
 800123a:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800123c:	9b01      	ldr	r3, [sp, #4]
 800123e:	4618      	mov	r0, r3
 8001240:	2100      	movs	r1, #0
 8001242:	f7ff fde5 	bl	8000e10 <chThdDequeueNextI>

  return Q_OK;
 8001246:	2300      	movs	r3, #0
}
 8001248:	4618      	mov	r0, r3
 800124a:	b003      	add	sp, #12
 800124c:	f85d fb04 	ldr.w	pc, [sp], #4

08001250 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001250:	b500      	push	{lr}
 8001252:	b085      	sub	sp, #20
 8001254:	9001      	str	r0, [sp, #4]
 8001256:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8001258:	f7ff ff32 	bl	80010c0 <chSysLock>
  if (iqp->q_notify != NULL) {
 800125c:	9b01      	ldr	r3, [sp, #4]
 800125e:	69db      	ldr	r3, [r3, #28]
 8001260:	2b00      	cmp	r3, #0
 8001262:	d003      	beq.n	800126c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8001264:	9b01      	ldr	r3, [sp, #4]
 8001266:	69db      	ldr	r3, [r3, #28]
 8001268:	9801      	ldr	r0, [sp, #4]
 800126a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
 800126c:	e00c      	b.n	8001288 <chIQGetTimeout+0x38>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800126e:	9b01      	ldr	r3, [sp, #4]
 8001270:	4618      	mov	r0, r3
 8001272:	9900      	ldr	r1, [sp, #0]
 8001274:	f7ff fdac 	bl	8000dd0 <chThdEnqueueTimeoutS>
 8001278:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 800127a:	9b03      	ldr	r3, [sp, #12]
 800127c:	2b00      	cmp	r3, #0
 800127e:	da03      	bge.n	8001288 <chIQGetTimeout+0x38>
      chSysUnlock();
 8001280:	f7ff ff26 	bl	80010d0 <chSysUnlock>
      return msg;
 8001284:	9b03      	ldr	r3, [sp, #12]
 8001286:	e020      	b.n	80012ca <chIQGetTimeout+0x7a>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8001288:	9801      	ldr	r0, [sp, #4]
 800128a:	f7ff ff39 	bl	8001100 <chIQIsEmptyI>
 800128e:	4603      	mov	r3, r0
 8001290:	2b00      	cmp	r3, #0
 8001292:	d1ec      	bne.n	800126e <chIQGetTimeout+0x1e>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001294:	9b01      	ldr	r3, [sp, #4]
 8001296:	689b      	ldr	r3, [r3, #8]
 8001298:	1e5a      	subs	r2, r3, #1
 800129a:	9b01      	ldr	r3, [sp, #4]
 800129c:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800129e:	9b01      	ldr	r3, [sp, #4]
 80012a0:	699b      	ldr	r3, [r3, #24]
 80012a2:	1c59      	adds	r1, r3, #1
 80012a4:	9a01      	ldr	r2, [sp, #4]
 80012a6:	6191      	str	r1, [r2, #24]
 80012a8:	781b      	ldrb	r3, [r3, #0]
 80012aa:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 80012ae:	9b01      	ldr	r3, [sp, #4]
 80012b0:	699a      	ldr	r2, [r3, #24]
 80012b2:	9b01      	ldr	r3, [sp, #4]
 80012b4:	691b      	ldr	r3, [r3, #16]
 80012b6:	429a      	cmp	r2, r3
 80012b8:	d303      	bcc.n	80012c2 <chIQGetTimeout+0x72>
    iqp->q_rdptr = iqp->q_buffer;
 80012ba:	9b01      	ldr	r3, [sp, #4]
 80012bc:	68da      	ldr	r2, [r3, #12]
 80012be:	9b01      	ldr	r3, [sp, #4]
 80012c0:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 80012c2:	f7ff ff05 	bl	80010d0 <chSysUnlock>

  return (msg_t)b;
 80012c6:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80012ca:	4618      	mov	r0, r3
 80012cc:	b005      	add	sp, #20
 80012ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80012d2:	bf00      	nop
 80012d4:	f3af 8000 	nop.w
 80012d8:	f3af 8000 	nop.w
 80012dc:	f3af 8000 	nop.w

080012e0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 80012e0:	b500      	push	{lr}
 80012e2:	b087      	sub	sp, #28
 80012e4:	9003      	str	r0, [sp, #12]
 80012e6:	9102      	str	r1, [sp, #8]
 80012e8:	9201      	str	r2, [sp, #4]
 80012ea:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 80012ec:	9b03      	ldr	r3, [sp, #12]
 80012ee:	69db      	ldr	r3, [r3, #28]
 80012f0:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 80012f2:	2300      	movs	r3, #0
 80012f4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 80012f6:	f7ff fee3 	bl	80010c0 <chSysLock>
  while (true) {
    if (nfy != NULL) {
 80012fa:	9b04      	ldr	r3, [sp, #16]
 80012fc:	2b00      	cmp	r3, #0
 80012fe:	d002      	beq.n	8001306 <chIQReadTimeout+0x26>
      nfy(iqp);
 8001300:	9b04      	ldr	r3, [sp, #16]
 8001302:	9803      	ldr	r0, [sp, #12]
 8001304:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
 8001306:	e00b      	b.n	8001320 <chIQReadTimeout+0x40>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8001308:	9b03      	ldr	r3, [sp, #12]
 800130a:	4618      	mov	r0, r3
 800130c:	9900      	ldr	r1, [sp, #0]
 800130e:	f7ff fd5f 	bl	8000dd0 <chThdEnqueueTimeoutS>
 8001312:	4603      	mov	r3, r0
 8001314:	2b00      	cmp	r3, #0
 8001316:	d003      	beq.n	8001320 <chIQReadTimeout+0x40>
        chSysUnlock();
 8001318:	f7ff feda 	bl	80010d0 <chSysUnlock>
        return r;
 800131c:	9b05      	ldr	r3, [sp, #20]
 800131e:	e02e      	b.n	800137e <chIQReadTimeout+0x9e>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8001320:	9803      	ldr	r0, [sp, #12]
 8001322:	f7ff feed 	bl	8001100 <chIQIsEmptyI>
 8001326:	4603      	mov	r3, r0
 8001328:	2b00      	cmp	r3, #0
 800132a:	d1ed      	bne.n	8001308 <chIQReadTimeout+0x28>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800132c:	9b03      	ldr	r3, [sp, #12]
 800132e:	689b      	ldr	r3, [r3, #8]
 8001330:	1e5a      	subs	r2, r3, #1
 8001332:	9b03      	ldr	r3, [sp, #12]
 8001334:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8001336:	9b02      	ldr	r3, [sp, #8]
 8001338:	1c5a      	adds	r2, r3, #1
 800133a:	9202      	str	r2, [sp, #8]
 800133c:	9a03      	ldr	r2, [sp, #12]
 800133e:	6992      	ldr	r2, [r2, #24]
 8001340:	1c50      	adds	r0, r2, #1
 8001342:	9903      	ldr	r1, [sp, #12]
 8001344:	6188      	str	r0, [r1, #24]
 8001346:	7812      	ldrb	r2, [r2, #0]
 8001348:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800134a:	9b03      	ldr	r3, [sp, #12]
 800134c:	699a      	ldr	r2, [r3, #24]
 800134e:	9b03      	ldr	r3, [sp, #12]
 8001350:	691b      	ldr	r3, [r3, #16]
 8001352:	429a      	cmp	r2, r3
 8001354:	d303      	bcc.n	800135e <chIQReadTimeout+0x7e>
      iqp->q_rdptr = iqp->q_buffer;
 8001356:	9b03      	ldr	r3, [sp, #12]
 8001358:	68da      	ldr	r2, [r3, #12]
 800135a:	9b03      	ldr	r3, [sp, #12]
 800135c:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800135e:	f7ff feb7 	bl	80010d0 <chSysUnlock>

    r++;
 8001362:	9b05      	ldr	r3, [sp, #20]
 8001364:	3301      	adds	r3, #1
 8001366:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	3b01      	subs	r3, #1
 800136c:	9301      	str	r3, [sp, #4]
 800136e:	9b01      	ldr	r3, [sp, #4]
 8001370:	2b00      	cmp	r3, #0
 8001372:	d101      	bne.n	8001378 <chIQReadTimeout+0x98>
      return r;
 8001374:	9b05      	ldr	r3, [sp, #20]
 8001376:	e002      	b.n	800137e <chIQReadTimeout+0x9e>
    }

    chSysLock();
 8001378:	f7ff fea2 	bl	80010c0 <chSysLock>
  }
 800137c:	e7bd      	b.n	80012fa <chIQReadTimeout+0x1a>
}
 800137e:	4618      	mov	r0, r3
 8001380:	b007      	add	sp, #28
 8001382:	f85d fb04 	ldr.w	pc, [sp], #4
 8001386:	bf00      	nop
 8001388:	f3af 8000 	nop.w
 800138c:	f3af 8000 	nop.w

08001390 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8001390:	b500      	push	{lr}
 8001392:	b085      	sub	sp, #20
 8001394:	9003      	str	r0, [sp, #12]
 8001396:	9102      	str	r1, [sp, #8]
 8001398:	9201      	str	r2, [sp, #4]
 800139a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	4618      	mov	r0, r3
 80013a0:	f7ff fe9e 	bl	80010e0 <chThdQueueObjectInit>
  oqp->q_counter = size;
 80013a4:	9b03      	ldr	r3, [sp, #12]
 80013a6:	9a01      	ldr	r2, [sp, #4]
 80013a8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 80013aa:	9b03      	ldr	r3, [sp, #12]
 80013ac:	9a02      	ldr	r2, [sp, #8]
 80013ae:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80013b0:	9b03      	ldr	r3, [sp, #12]
 80013b2:	9a02      	ldr	r2, [sp, #8]
 80013b4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80013b6:	9b03      	ldr	r3, [sp, #12]
 80013b8:	9a02      	ldr	r2, [sp, #8]
 80013ba:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 80013bc:	9a02      	ldr	r2, [sp, #8]
 80013be:	9b01      	ldr	r3, [sp, #4]
 80013c0:	441a      	add	r2, r3
 80013c2:	9b03      	ldr	r3, [sp, #12]
 80013c4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 80013c6:	9b03      	ldr	r3, [sp, #12]
 80013c8:	9a00      	ldr	r2, [sp, #0]
 80013ca:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 80013cc:	9b03      	ldr	r3, [sp, #12]
 80013ce:	9a06      	ldr	r2, [sp, #24]
 80013d0:	621a      	str	r2, [r3, #32]
}
 80013d2:	b005      	add	sp, #20
 80013d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80013d8:	f3af 8000 	nop.w
 80013dc:	f3af 8000 	nop.w

080013e0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80013e0:	b500      	push	{lr}
 80013e2:	b087      	sub	sp, #28
 80013e4:	9003      	str	r0, [sp, #12]
 80013e6:	460b      	mov	r3, r1
 80013e8:	9201      	str	r2, [sp, #4]
 80013ea:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 80013ee:	f7ff fe67 	bl	80010c0 <chSysLock>
  while (chOQIsFullI(oqp)) {
 80013f2:	e00c      	b.n	800140e <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80013f4:	9b03      	ldr	r3, [sp, #12]
 80013f6:	4618      	mov	r0, r3
 80013f8:	9901      	ldr	r1, [sp, #4]
 80013fa:	f7ff fce9 	bl	8000dd0 <chThdEnqueueTimeoutS>
 80013fe:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8001400:	9b05      	ldr	r3, [sp, #20]
 8001402:	2b00      	cmp	r3, #0
 8001404:	da03      	bge.n	800140e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8001406:	f7ff fe63 	bl	80010d0 <chSysUnlock>
      return msg;
 800140a:	9b05      	ldr	r3, [sp, #20]
 800140c:	e027      	b.n	800145e <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800140e:	9803      	ldr	r0, [sp, #12]
 8001410:	f7ff feb6 	bl	8001180 <chOQIsFullI>
 8001414:	4603      	mov	r3, r0
 8001416:	2b00      	cmp	r3, #0
 8001418:	d1ec      	bne.n	80013f4 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800141a:	9b03      	ldr	r3, [sp, #12]
 800141c:	689b      	ldr	r3, [r3, #8]
 800141e:	1e5a      	subs	r2, r3, #1
 8001420:	9b03      	ldr	r3, [sp, #12]
 8001422:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8001424:	9b03      	ldr	r3, [sp, #12]
 8001426:	695b      	ldr	r3, [r3, #20]
 8001428:	1c59      	adds	r1, r3, #1
 800142a:	9a03      	ldr	r2, [sp, #12]
 800142c:	6151      	str	r1, [r2, #20]
 800142e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8001432:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001434:	9b03      	ldr	r3, [sp, #12]
 8001436:	695a      	ldr	r2, [r3, #20]
 8001438:	9b03      	ldr	r3, [sp, #12]
 800143a:	691b      	ldr	r3, [r3, #16]
 800143c:	429a      	cmp	r2, r3
 800143e:	d303      	bcc.n	8001448 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 8001440:	9b03      	ldr	r3, [sp, #12]
 8001442:	68da      	ldr	r2, [r3, #12]
 8001444:	9b03      	ldr	r3, [sp, #12]
 8001446:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 8001448:	9b03      	ldr	r3, [sp, #12]
 800144a:	69db      	ldr	r3, [r3, #28]
 800144c:	2b00      	cmp	r3, #0
 800144e:	d003      	beq.n	8001458 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 8001450:	9b03      	ldr	r3, [sp, #12]
 8001452:	69db      	ldr	r3, [r3, #28]
 8001454:	9803      	ldr	r0, [sp, #12]
 8001456:	4798      	blx	r3
  }
  chSysUnlock();
 8001458:	f7ff fe3a 	bl	80010d0 <chSysUnlock>

  return Q_OK;
 800145c:	2300      	movs	r3, #0
}
 800145e:	4618      	mov	r0, r3
 8001460:	b007      	add	sp, #28
 8001462:	f85d fb04 	ldr.w	pc, [sp], #4
 8001466:	bf00      	nop
 8001468:	f3af 8000 	nop.w
 800146c:	f3af 8000 	nop.w

08001470 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8001470:	b500      	push	{lr}
 8001472:	b085      	sub	sp, #20
 8001474:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 8001476:	9801      	ldr	r0, [sp, #4]
 8001478:	f7ff fe6a 	bl	8001150 <chOQIsEmptyI>
 800147c:	4603      	mov	r3, r0
 800147e:	2b00      	cmp	r3, #0
 8001480:	d002      	beq.n	8001488 <chOQGetI+0x18>
    return Q_EMPTY;
 8001482:	f06f 0302 	mvn.w	r3, #2
 8001486:	e01d      	b.n	80014c4 <chOQGetI+0x54>
  }

  oqp->q_counter++;
 8001488:	9b01      	ldr	r3, [sp, #4]
 800148a:	689b      	ldr	r3, [r3, #8]
 800148c:	1c5a      	adds	r2, r3, #1
 800148e:	9b01      	ldr	r3, [sp, #4]
 8001490:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8001492:	9b01      	ldr	r3, [sp, #4]
 8001494:	699b      	ldr	r3, [r3, #24]
 8001496:	1c59      	adds	r1, r3, #1
 8001498:	9a01      	ldr	r2, [sp, #4]
 800149a:	6191      	str	r1, [r2, #24]
 800149c:	781b      	ldrb	r3, [r3, #0]
 800149e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 80014a2:	9b01      	ldr	r3, [sp, #4]
 80014a4:	699a      	ldr	r2, [r3, #24]
 80014a6:	9b01      	ldr	r3, [sp, #4]
 80014a8:	691b      	ldr	r3, [r3, #16]
 80014aa:	429a      	cmp	r2, r3
 80014ac:	d303      	bcc.n	80014b6 <chOQGetI+0x46>
    oqp->q_rdptr = oqp->q_buffer;
 80014ae:	9b01      	ldr	r3, [sp, #4]
 80014b0:	68da      	ldr	r2, [r3, #12]
 80014b2:	9b01      	ldr	r3, [sp, #4]
 80014b4:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 80014b6:	9b01      	ldr	r3, [sp, #4]
 80014b8:	4618      	mov	r0, r3
 80014ba:	2100      	movs	r1, #0
 80014bc:	f7ff fca8 	bl	8000e10 <chThdDequeueNextI>

  return (msg_t)b;
 80014c0:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80014c4:	4618      	mov	r0, r3
 80014c6:	b005      	add	sp, #20
 80014c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80014cc:	f3af 8000 	nop.w

080014d0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 80014d0:	b500      	push	{lr}
 80014d2:	b087      	sub	sp, #28
 80014d4:	9003      	str	r0, [sp, #12]
 80014d6:	9102      	str	r1, [sp, #8]
 80014d8:	9201      	str	r2, [sp, #4]
 80014da:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 80014dc:	9b03      	ldr	r3, [sp, #12]
 80014de:	69db      	ldr	r3, [r3, #28]
 80014e0:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 80014e2:	2300      	movs	r3, #0
 80014e4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 80014e6:	f7ff fdeb 	bl	80010c0 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
 80014ea:	e00b      	b.n	8001504 <chOQWriteTimeout+0x34>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80014ec:	9b03      	ldr	r3, [sp, #12]
 80014ee:	4618      	mov	r0, r3
 80014f0:	9900      	ldr	r1, [sp, #0]
 80014f2:	f7ff fc6d 	bl	8000dd0 <chThdEnqueueTimeoutS>
 80014f6:	4603      	mov	r3, r0
 80014f8:	2b00      	cmp	r3, #0
 80014fa:	d003      	beq.n	8001504 <chOQWriteTimeout+0x34>
        chSysUnlock();
 80014fc:	f7ff fde8 	bl	80010d0 <chSysUnlock>
        return w;
 8001500:	9b05      	ldr	r3, [sp, #20]
 8001502:	e034      	b.n	800156e <chOQWriteTimeout+0x9e>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001504:	9803      	ldr	r0, [sp, #12]
 8001506:	f7ff fe3b 	bl	8001180 <chOQIsFullI>
 800150a:	4603      	mov	r3, r0
 800150c:	2b00      	cmp	r3, #0
 800150e:	d1ed      	bne.n	80014ec <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001510:	9b03      	ldr	r3, [sp, #12]
 8001512:	689b      	ldr	r3, [r3, #8]
 8001514:	1e5a      	subs	r2, r3, #1
 8001516:	9b03      	ldr	r3, [sp, #12]
 8001518:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 800151a:	9b03      	ldr	r3, [sp, #12]
 800151c:	695b      	ldr	r3, [r3, #20]
 800151e:	1c59      	adds	r1, r3, #1
 8001520:	9a03      	ldr	r2, [sp, #12]
 8001522:	6151      	str	r1, [r2, #20]
 8001524:	9a02      	ldr	r2, [sp, #8]
 8001526:	1c51      	adds	r1, r2, #1
 8001528:	9102      	str	r1, [sp, #8]
 800152a:	7812      	ldrb	r2, [r2, #0]
 800152c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800152e:	9b03      	ldr	r3, [sp, #12]
 8001530:	695a      	ldr	r2, [r3, #20]
 8001532:	9b03      	ldr	r3, [sp, #12]
 8001534:	691b      	ldr	r3, [r3, #16]
 8001536:	429a      	cmp	r2, r3
 8001538:	d303      	bcc.n	8001542 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 800153a:	9b03      	ldr	r3, [sp, #12]
 800153c:	68da      	ldr	r2, [r3, #12]
 800153e:	9b03      	ldr	r3, [sp, #12]
 8001540:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 8001542:	9b04      	ldr	r3, [sp, #16]
 8001544:	2b00      	cmp	r3, #0
 8001546:	d002      	beq.n	800154e <chOQWriteTimeout+0x7e>
      nfy(oqp);
 8001548:	9b04      	ldr	r3, [sp, #16]
 800154a:	9803      	ldr	r0, [sp, #12]
 800154c:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800154e:	f7ff fdbf 	bl	80010d0 <chSysUnlock>

    w++;
 8001552:	9b05      	ldr	r3, [sp, #20]
 8001554:	3301      	adds	r3, #1
 8001556:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8001558:	9b01      	ldr	r3, [sp, #4]
 800155a:	3b01      	subs	r3, #1
 800155c:	9301      	str	r3, [sp, #4]
 800155e:	9b01      	ldr	r3, [sp, #4]
 8001560:	2b00      	cmp	r3, #0
 8001562:	d101      	bne.n	8001568 <chOQWriteTimeout+0x98>
      return w;
 8001564:	9b05      	ldr	r3, [sp, #20]
 8001566:	e002      	b.n	800156e <chOQWriteTimeout+0x9e>
    }
    chSysLock();
 8001568:	f7ff fdaa 	bl	80010c0 <chSysLock>
  }
 800156c:	e7bd      	b.n	80014ea <chOQWriteTimeout+0x1a>
}
 800156e:	4618      	mov	r0, r3
 8001570:	b007      	add	sp, #28
 8001572:	f85d fb04 	ldr.w	pc, [sp], #4
 8001576:	bf00      	nop
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001580:	b082      	sub	sp, #8
 8001582:	2320      	movs	r3, #32
 8001584:	9301      	str	r3, [sp, #4]
 8001586:	9b01      	ldr	r3, [sp, #4]
 8001588:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800158c:	b002      	add	sp, #8
 800158e:	4770      	bx	lr

08001590 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001590:	b082      	sub	sp, #8
 8001592:	2300      	movs	r3, #0
 8001594:	9301      	str	r3, [sp, #4]
 8001596:	9b01      	ldr	r3, [sp, #4]
 8001598:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800159c:	b002      	add	sp, #8
 800159e:	4770      	bx	lr

080015a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 80015a0:	b508      	push	{r3, lr}

  port_lock();
 80015a2:	f7ff ffed 	bl	8001580 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80015a6:	bd08      	pop	{r3, pc}
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80015b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 80015b2:	f7ff ffed 	bl	8001590 <port_unlock>
}
 80015b6:	bd08      	pop	{r3, pc}
 80015b8:	f3af 8000 	nop.w
 80015bc:	f3af 8000 	nop.w

080015c0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80015c0:	4b06      	ldr	r3, [pc, #24]	; (80015dc <_core_init+0x1c>)
 80015c2:	3307      	adds	r3, #7
 80015c4:	f023 0307 	bic.w	r3, r3, #7
 80015c8:	461a      	mov	r2, r3
 80015ca:	4b05      	ldr	r3, [pc, #20]	; (80015e0 <_core_init+0x20>)
 80015cc:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80015ce:	4b05      	ldr	r3, [pc, #20]	; (80015e4 <_core_init+0x24>)
 80015d0:	f023 0307 	bic.w	r3, r3, #7
 80015d4:	461a      	mov	r2, r3
 80015d6:	4b04      	ldr	r3, [pc, #16]	; (80015e8 <_core_init+0x28>)
 80015d8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 80015da:	4770      	bx	lr
 80015dc:	20000d98 	.word	0x20000d98
 80015e0:	200009d8 	.word	0x200009d8
 80015e4:	20020000 	.word	0x20020000
 80015e8:	200009dc 	.word	0x200009dc
 80015ec:	f3af 8000 	nop.w

080015f0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80015f0:	b500      	push	{lr}
 80015f2:	b085      	sub	sp, #20
 80015f4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 80015f6:	f7ff ffd3 	bl	80015a0 <chSysLock>
  p = chCoreAllocI(size);
 80015fa:	9801      	ldr	r0, [sp, #4]
 80015fc:	f000 f808 	bl	8001610 <chCoreAllocI>
 8001600:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001602:	f7ff ffd5 	bl	80015b0 <chSysUnlock>

  return p;
 8001606:	9b03      	ldr	r3, [sp, #12]
}
 8001608:	4618      	mov	r0, r3
 800160a:	b005      	add	sp, #20
 800160c:	f85d fb04 	ldr.w	pc, [sp], #4

08001610 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8001610:	b084      	sub	sp, #16
 8001612:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001614:	9b01      	ldr	r3, [sp, #4]
 8001616:	3307      	adds	r3, #7
 8001618:	f023 0307 	bic.w	r3, r3, #7
 800161c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800161e:	4b0c      	ldr	r3, [pc, #48]	; (8001650 <chCoreAllocI+0x40>)
 8001620:	681b      	ldr	r3, [r3, #0]
 8001622:	461a      	mov	r2, r3
 8001624:	4b0b      	ldr	r3, [pc, #44]	; (8001654 <chCoreAllocI+0x44>)
 8001626:	681b      	ldr	r3, [r3, #0]
 8001628:	1ad3      	subs	r3, r2, r3
 800162a:	461a      	mov	r2, r3
 800162c:	9b01      	ldr	r3, [sp, #4]
 800162e:	429a      	cmp	r2, r3
 8001630:	d201      	bcs.n	8001636 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 8001632:	2300      	movs	r3, #0
 8001634:	e009      	b.n	800164a <chCoreAllocI+0x3a>
  }
  p = nextmem;
 8001636:	4b07      	ldr	r3, [pc, #28]	; (8001654 <chCoreAllocI+0x44>)
 8001638:	681b      	ldr	r3, [r3, #0]
 800163a:	9303      	str	r3, [sp, #12]
  nextmem += size;
 800163c:	4b05      	ldr	r3, [pc, #20]	; (8001654 <chCoreAllocI+0x44>)
 800163e:	681a      	ldr	r2, [r3, #0]
 8001640:	9b01      	ldr	r3, [sp, #4]
 8001642:	4413      	add	r3, r2
 8001644:	4a03      	ldr	r2, [pc, #12]	; (8001654 <chCoreAllocI+0x44>)
 8001646:	6013      	str	r3, [r2, #0]

  return p;
 8001648:	9b03      	ldr	r3, [sp, #12]
}
 800164a:	4618      	mov	r0, r3
 800164c:	b004      	add	sp, #16
 800164e:	4770      	bx	lr
 8001650:	200009dc 	.word	0x200009dc
 8001654:	200009d8 	.word	0x200009d8
 8001658:	f3af 8000 	nop.w
 800165c:	f3af 8000 	nop.w

08001660 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8001660:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8001662:	4b06      	ldr	r3, [pc, #24]	; (800167c <_heap_init+0x1c>)
 8001664:	4a06      	ldr	r2, [pc, #24]	; (8001680 <_heap_init+0x20>)
 8001666:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8001668:	4b04      	ldr	r3, [pc, #16]	; (800167c <_heap_init+0x1c>)
 800166a:	2200      	movs	r2, #0
 800166c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800166e:	4b03      	ldr	r3, [pc, #12]	; (800167c <_heap_init+0x1c>)
 8001670:	2200      	movs	r2, #0
 8001672:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001674:	4803      	ldr	r0, [pc, #12]	; (8001684 <_heap_init+0x24>)
 8001676:	f7ff fc93 	bl	8000fa0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800167a:	bd08      	pop	{r3, pc}
 800167c:	200009e0 	.word	0x200009e0
 8001680:	080015f1 	.word	0x080015f1
 8001684:	200009f0 	.word	0x200009f0
 8001688:	f3af 8000 	nop.w
 800168c:	f3af 8000 	nop.w

08001690 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001690:	b082      	sub	sp, #8
 8001692:	2320      	movs	r3, #32
 8001694:	9301      	str	r3, [sp, #4]
 8001696:	9b01      	ldr	r3, [sp, #4]
 8001698:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800169c:	b002      	add	sp, #8
 800169e:	4770      	bx	lr

080016a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80016a0:	b082      	sub	sp, #8
 80016a2:	2300      	movs	r3, #0
 80016a4:	9301      	str	r3, [sp, #4]
 80016a6:	9b01      	ldr	r3, [sp, #4]
 80016a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80016ac:	b002      	add	sp, #8
 80016ae:	4770      	bx	lr

080016b0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80016b0:	b508      	push	{r3, lr}

  port_lock();
 80016b2:	f7ff ffed 	bl	8001690 <port_lock>
}
 80016b6:	bd08      	pop	{r3, pc}
 80016b8:	f3af 8000 	nop.w
 80016bc:	f3af 8000 	nop.w

080016c0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80016c0:	b508      	push	{r3, lr}

  port_unlock();
 80016c2:	f7ff ffed 	bl	80016a0 <port_unlock>
}
 80016c6:	bd08      	pop	{r3, pc}
 80016c8:	f3af 8000 	nop.w
 80016cc:	f3af 8000 	nop.w

080016d0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 80016d0:	b510      	push	{r4, lr}
 80016d2:	b082      	sub	sp, #8
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 80016d4:	4a0b      	ldr	r2, [pc, #44]	; (8001704 <SVC_Handler+0x34>)
 80016d6:	4b0b      	ldr	r3, [pc, #44]	; (8001704 <SVC_Handler+0x34>)
 80016d8:	685b      	ldr	r3, [r3, #4]
 80016da:	f023 0301 	bic.w	r3, r3, #1
 80016de:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80016e0:	f3ef 8309 	mrs	r3, PSP
 80016e4:	461c      	mov	r4, r3
  return(result);
 80016e6:	4623      	mov	r3, r4
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 80016e8:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80016ea:	9b01      	ldr	r3, [sp, #4]
 80016ec:	3368      	adds	r3, #104	; 0x68
 80016ee:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 80016f0:	9b01      	ldr	r3, [sp, #4]
 80016f2:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80016f4:	9b00      	ldr	r3, [sp, #0]
 80016f6:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 80016fa:	f7ff ffe1 	bl	80016c0 <port_unlock_from_isr>
}
 80016fe:	b002      	add	sp, #8
 8001700:	bd10      	pop	{r4, pc}
 8001702:	bf00      	nop
 8001704:	e000ef30 	.word	0xe000ef30
 8001708:	f3af 8000 	nop.w
 800170c:	f3af 8000 	nop.w

08001710 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8001710:	b510      	push	{r4, lr}
 8001712:	b084      	sub	sp, #16

  port_lock_from_isr();
 8001714:	f7ff ffcc 	bl	80016b0 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001718:	4b17      	ldr	r3, [pc, #92]	; (8001778 <_port_irq_epilogue+0x68>)
 800171a:	685b      	ldr	r3, [r3, #4]
 800171c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001720:	2b00      	cmp	r3, #0
 8001722:	d025      	beq.n	8001770 <_port_irq_epilogue+0x60>
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8001724:	eef1 3a10 	vmrs	r3, fpscr
 8001728:	9302      	str	r3, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800172a:	f3ef 8309 	mrs	r3, PSP
 800172e:	461c      	mov	r4, r3
  return(result);
 8001730:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8001732:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001734:	9b03      	ldr	r3, [sp, #12]
 8001736:	3b68      	subs	r3, #104	; 0x68
 8001738:	9303      	str	r3, [sp, #12]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800173a:	9b03      	ldr	r3, [sp, #12]
 800173c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8001740:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8001742:	4b0e      	ldr	r3, [pc, #56]	; (800177c <_port_irq_epilogue+0x6c>)
 8001744:	68db      	ldr	r3, [r3, #12]
 8001746:	461a      	mov	r2, r3
 8001748:	9b03      	ldr	r3, [sp, #12]
 800174a:	661a      	str	r2, [r3, #96]	; 0x60
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 800174c:	9b03      	ldr	r3, [sp, #12]
 800174e:	9301      	str	r3, [sp, #4]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001750:	9b01      	ldr	r3, [sp, #4]
 8001752:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001756:	f7ff f92b 	bl	80009b0 <chSchIsPreemptionRequired>
 800175a:	4603      	mov	r3, r0
 800175c:	2b00      	cmp	r3, #0
 800175e:	d003      	beq.n	8001768 <_port_irq_epilogue+0x58>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001760:	9b03      	ldr	r3, [sp, #12]
 8001762:	4a07      	ldr	r2, [pc, #28]	; (8001780 <_port_irq_epilogue+0x70>)
 8001764:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8001766:	e005      	b.n	8001774 <_port_irq_epilogue+0x64>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001768:	9b03      	ldr	r3, [sp, #12]
 800176a:	4a06      	ldr	r2, [pc, #24]	; (8001784 <_port_irq_epilogue+0x74>)
 800176c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 800176e:	e001      	b.n	8001774 <_port_irq_epilogue+0x64>
  }
  port_unlock_from_isr();
 8001770:	f7ff ffa6 	bl	80016c0 <port_unlock_from_isr>
}
 8001774:	b004      	add	sp, #16
 8001776:	bd10      	pop	{r4, pc}
 8001778:	e000ed00 	.word	0xe000ed00
 800177c:	e000ef30 	.word	0xe000ef30
 8001780:	080002e9 	.word	0x080002e9
 8001784:	080002ec 	.word	0x080002ec
 8001788:	f3af 8000 	nop.w
 800178c:	f3af 8000 	nop.w

08001790 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8001790:	4770      	bx	lr
 8001792:	bf00      	nop
 8001794:	f3af 8000 	nop.w
 8001798:	f3af 8000 	nop.w
 800179c:	f3af 8000 	nop.w

080017a0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80017a0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80017a2:	f7ff fff5 	bl	8001790 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 80017a6:	f000 fcdb 	bl	8002160 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 80017aa:	4808      	ldr	r0, [pc, #32]	; (80017cc <halInit+0x2c>)
 80017ac:	f000 ff70 	bl	8002690 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 80017b0:	f000 f826 	bl	8001800 <adcInit>
#endif
#if (HAL_USE_I2S == TRUE) || defined(__DOXYGEN__)
  i2sInit();
#endif
#if (HAL_USE_ICU == TRUE) || defined(__DOXYGEN__)
  icuInit();
 80017b4:	f000 f84c 	bl	8001850 <icuInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 80017b8:	f000 f97a 	bl	8001ab0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 80017bc:	f000 fa10 	bl	8001be0 <spiInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80017c0:	f001 fb36 	bl	8002e30 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80017c4:	f000 f804 	bl	80017d0 <stInit>
#endif
}
 80017c8:	bd08      	pop	{r3, pc}
 80017ca:	bf00      	nop
 80017cc:	080030d0 	.word	0x080030d0

080017d0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80017d0:	b508      	push	{r3, lr}

  st_lld_init();
 80017d2:	f000 fde5 	bl	80023a0 <st_lld_init>
}
 80017d6:	bd08      	pop	{r3, pc}
 80017d8:	f3af 8000 	nop.w
 80017dc:	f3af 8000 	nop.w

080017e0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80017e0:	b500      	push	{lr}
 80017e2:	b083      	sub	sp, #12
 80017e4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80017e6:	9801      	ldr	r0, [sp, #4]
 80017e8:	f7ff fbda 	bl	8000fa0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80017ec:	b003      	add	sp, #12
 80017ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80017f2:	bf00      	nop
 80017f4:	f3af 8000 	nop.w
 80017f8:	f3af 8000 	nop.w
 80017fc:	f3af 8000 	nop.w

08001800 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
 8001800:	b508      	push	{r3, lr}

  adc_lld_init();
 8001802:	f000 febd 	bl	8002580 <adc_lld_init>
}
 8001806:	bd08      	pop	{r3, pc}
 8001808:	f3af 8000 	nop.w
 800180c:	f3af 8000 	nop.w

08001810 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
 8001810:	b500      	push	{lr}
 8001812:	b083      	sub	sp, #12
 8001814:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
 8001816:	9b01      	ldr	r3, [sp, #4]
 8001818:	2201      	movs	r2, #1
 800181a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
 800181c:	9b01      	ldr	r3, [sp, #4]
 800181e:	2200      	movs	r2, #0
 8001820:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
 8001822:	9b01      	ldr	r3, [sp, #4]
 8001824:	2200      	movs	r2, #0
 8001826:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
 8001828:	9b01      	ldr	r3, [sp, #4]
 800182a:	2200      	movs	r2, #0
 800182c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
 800182e:	9b01      	ldr	r3, [sp, #4]
 8001830:	2200      	movs	r2, #0
 8001832:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8001834:	9b01      	ldr	r3, [sp, #4]
 8001836:	2200      	movs	r2, #0
 8001838:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
 800183a:	9b01      	ldr	r3, [sp, #4]
 800183c:	3318      	adds	r3, #24
 800183e:	4618      	mov	r0, r3
 8001840:	f7ff ffce 	bl	80017e0 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
 8001844:	b003      	add	sp, #12
 8001846:	f85d fb04 	ldr.w	pc, [sp], #4
 800184a:	bf00      	nop
 800184c:	f3af 8000 	nop.w

08001850 <icuInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void icuInit(void) {
 8001850:	b508      	push	{r3, lr}

  icu_lld_init();
 8001852:	f001 f8dd 	bl	8002a10 <icu_lld_init>
}
 8001856:	bd08      	pop	{r3, pc}
 8001858:	f3af 8000 	nop.w
 800185c:	f3af 8000 	nop.w

08001860 <icuObjectInit>:
 *
 * @param[out] icup     pointer to the @p ICUDriver object
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {
 8001860:	b082      	sub	sp, #8
 8001862:	9001      	str	r0, [sp, #4]

  icup->state  = ICU_STOP;
 8001864:	9b01      	ldr	r3, [sp, #4]
 8001866:	2201      	movs	r2, #1
 8001868:	701a      	strb	r2, [r3, #0]
  icup->config = NULL;
 800186a:	9b01      	ldr	r3, [sp, #4]
 800186c:	2200      	movs	r2, #0
 800186e:	605a      	str	r2, [r3, #4]
}
 8001870:	b002      	add	sp, #8
 8001872:	4770      	bx	lr
 8001874:	f3af 8000 	nop.w
 8001878:	f3af 8000 	nop.w
 800187c:	f3af 8000 	nop.w

08001880 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001880:	b082      	sub	sp, #8
 8001882:	2320      	movs	r3, #32
 8001884:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001886:	9b01      	ldr	r3, [sp, #4]
 8001888:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800188c:	b002      	add	sp, #8
 800188e:	4770      	bx	lr

08001890 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001890:	b082      	sub	sp, #8
 8001892:	2300      	movs	r3, #0
 8001894:	9301      	str	r3, [sp, #4]
 8001896:	9b01      	ldr	r3, [sp, #4]
 8001898:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800189c:	b002      	add	sp, #8
 800189e:	4770      	bx	lr

080018a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 80018a0:	b508      	push	{r3, lr}

  port_lock();
 80018a2:	f7ff ffed 	bl	8001880 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80018a6:	bd08      	pop	{r3, pc}
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80018b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 80018b2:	f7ff ffed 	bl	8001890 <port_unlock>
}
 80018b6:	bd08      	pop	{r3, pc}
 80018b8:	f3af 8000 	nop.w
 80018bc:	f3af 8000 	nop.w

080018c0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80018c0:	b082      	sub	sp, #8
 80018c2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 80018c4:	9b01      	ldr	r3, [sp, #4]
 80018c6:	9a01      	ldr	r2, [sp, #4]
 80018c8:	601a      	str	r2, [r3, #0]
}
 80018ca:	b002      	add	sp, #8
 80018cc:	4770      	bx	lr
 80018ce:	bf00      	nop

080018d0 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 80018d0:	b082      	sub	sp, #8
 80018d2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80018d4:	9b01      	ldr	r3, [sp, #4]
 80018d6:	689b      	ldr	r3, [r3, #8]
 80018d8:	2b00      	cmp	r3, #0
 80018da:	bf0c      	ite	eq
 80018dc:	2301      	moveq	r3, #1
 80018de:	2300      	movne	r3, #0
 80018e0:	b2db      	uxtb	r3, r3
}
 80018e2:	4618      	mov	r0, r3
 80018e4:	b002      	add	sp, #8
 80018e6:	4770      	bx	lr
 80018e8:	f3af 8000 	nop.w
 80018ec:	f3af 8000 	nop.w

080018f0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80018f0:	b508      	push	{r3, lr}

  chSysLock();
 80018f2:	f7ff ffd5 	bl	80018a0 <chSysLock>
}
 80018f6:	bd08      	pop	{r3, pc}
 80018f8:	f3af 8000 	nop.w
 80018fc:	f3af 8000 	nop.w

08001900 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8001900:	b508      	push	{r3, lr}

  chSysUnlock();
 8001902:	f7ff ffd5 	bl	80018b0 <chSysUnlock>
}
 8001906:	bd08      	pop	{r3, pc}
 8001908:	f3af 8000 	nop.w
 800190c:	f3af 8000 	nop.w

08001910 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8001910:	b500      	push	{lr}
 8001912:	b083      	sub	sp, #12
 8001914:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8001916:	9801      	ldr	r0, [sp, #4]
 8001918:	f7ff ffd2 	bl	80018c0 <chEvtObjectInit>
}
 800191c:	b003      	add	sp, #12
 800191e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001922:	bf00      	nop
 8001924:	f3af 8000 	nop.w
 8001928:	f3af 8000 	nop.w
 800192c:	f3af 8000 	nop.w

08001930 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8001930:	b500      	push	{lr}
 8001932:	b083      	sub	sp, #12
 8001934:	9001      	str	r0, [sp, #4]
 8001936:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8001938:	9801      	ldr	r0, [sp, #4]
 800193a:	9900      	ldr	r1, [sp, #0]
 800193c:	f7ff fb40 	bl	8000fc0 <chEvtBroadcastFlagsI>
}
 8001940:	b003      	add	sp, #12
 8001942:	f85d fb04 	ldr.w	pc, [sp], #4
 8001946:	bf00      	nop
 8001948:	f3af 8000 	nop.w
 800194c:	f3af 8000 	nop.w

08001950 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8001950:	b500      	push	{lr}
 8001952:	b085      	sub	sp, #20
 8001954:	9003      	str	r0, [sp, #12]
 8001956:	9102      	str	r1, [sp, #8]
 8001958:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800195a:	9b03      	ldr	r3, [sp, #12]
 800195c:	3330      	adds	r3, #48	; 0x30
 800195e:	4618      	mov	r0, r3
 8001960:	9902      	ldr	r1, [sp, #8]
 8001962:	9a01      	ldr	r2, [sp, #4]
 8001964:	f04f 33ff 	mov.w	r3, #4294967295
 8001968:	f7ff fdb2 	bl	80014d0 <chOQWriteTimeout>
 800196c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800196e:	4618      	mov	r0, r3
 8001970:	b005      	add	sp, #20
 8001972:	f85d fb04 	ldr.w	pc, [sp], #4
 8001976:	bf00      	nop
 8001978:	f3af 8000 	nop.w
 800197c:	f3af 8000 	nop.w

08001980 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8001980:	b500      	push	{lr}
 8001982:	b085      	sub	sp, #20
 8001984:	9003      	str	r0, [sp, #12]
 8001986:	9102      	str	r1, [sp, #8]
 8001988:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800198a:	9b03      	ldr	r3, [sp, #12]
 800198c:	330c      	adds	r3, #12
 800198e:	4618      	mov	r0, r3
 8001990:	9902      	ldr	r1, [sp, #8]
 8001992:	9a01      	ldr	r2, [sp, #4]
 8001994:	f04f 33ff 	mov.w	r3, #4294967295
 8001998:	f7ff fca2 	bl	80012e0 <chIQReadTimeout>
 800199c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800199e:	4618      	mov	r0, r3
 80019a0:	b005      	add	sp, #20
 80019a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80019a6:	bf00      	nop
 80019a8:	f3af 8000 	nop.w
 80019ac:	f3af 8000 	nop.w

080019b0 <put>:

static msg_t put(void *ip, uint8_t b) {
 80019b0:	b500      	push	{lr}
 80019b2:	b083      	sub	sp, #12
 80019b4:	9001      	str	r0, [sp, #4]
 80019b6:	460b      	mov	r3, r1
 80019b8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80019bc:	9b01      	ldr	r3, [sp, #4]
 80019be:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80019c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80019c6:	4610      	mov	r0, r2
 80019c8:	4619      	mov	r1, r3
 80019ca:	f04f 32ff 	mov.w	r2, #4294967295
 80019ce:	f7ff fd07 	bl	80013e0 <chOQPutTimeout>
 80019d2:	4603      	mov	r3, r0
}
 80019d4:	4618      	mov	r0, r3
 80019d6:	b003      	add	sp, #12
 80019d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80019dc:	f3af 8000 	nop.w

080019e0 <get>:

static msg_t get(void *ip) {
 80019e0:	b500      	push	{lr}
 80019e2:	b083      	sub	sp, #12
 80019e4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80019e6:	9b01      	ldr	r3, [sp, #4]
 80019e8:	330c      	adds	r3, #12
 80019ea:	4618      	mov	r0, r3
 80019ec:	f04f 31ff 	mov.w	r1, #4294967295
 80019f0:	f7ff fc2e 	bl	8001250 <chIQGetTimeout>
 80019f4:	4603      	mov	r3, r0
}
 80019f6:	4618      	mov	r0, r3
 80019f8:	b003      	add	sp, #12
 80019fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80019fe:	bf00      	nop

08001a00 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8001a00:	b500      	push	{lr}
 8001a02:	b085      	sub	sp, #20
 8001a04:	9003      	str	r0, [sp, #12]
 8001a06:	460b      	mov	r3, r1
 8001a08:	9201      	str	r2, [sp, #4]
 8001a0a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001a0e:	9b03      	ldr	r3, [sp, #12]
 8001a10:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8001a14:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8001a18:	4610      	mov	r0, r2
 8001a1a:	4619      	mov	r1, r3
 8001a1c:	9a01      	ldr	r2, [sp, #4]
 8001a1e:	f7ff fcdf 	bl	80013e0 <chOQPutTimeout>
 8001a22:	4603      	mov	r3, r0
}
 8001a24:	4618      	mov	r0, r3
 8001a26:	b005      	add	sp, #20
 8001a28:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a2c:	f3af 8000 	nop.w

08001a30 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
 8001a30:	b500      	push	{lr}
 8001a32:	b083      	sub	sp, #12
 8001a34:	9001      	str	r0, [sp, #4]
 8001a36:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001a38:	9b01      	ldr	r3, [sp, #4]
 8001a3a:	330c      	adds	r3, #12
 8001a3c:	4618      	mov	r0, r3
 8001a3e:	9900      	ldr	r1, [sp, #0]
 8001a40:	f7ff fc06 	bl	8001250 <chIQGetTimeout>
 8001a44:	4603      	mov	r3, r0
}
 8001a46:	4618      	mov	r0, r3
 8001a48:	b003      	add	sp, #12
 8001a4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a4e:	bf00      	nop

08001a50 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8001a50:	b500      	push	{lr}
 8001a52:	b085      	sub	sp, #20
 8001a54:	9003      	str	r0, [sp, #12]
 8001a56:	9102      	str	r1, [sp, #8]
 8001a58:	9201      	str	r2, [sp, #4]
 8001a5a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001a5c:	9b03      	ldr	r3, [sp, #12]
 8001a5e:	3330      	adds	r3, #48	; 0x30
 8001a60:	4618      	mov	r0, r3
 8001a62:	9902      	ldr	r1, [sp, #8]
 8001a64:	9a01      	ldr	r2, [sp, #4]
 8001a66:	9b00      	ldr	r3, [sp, #0]
 8001a68:	f7ff fd32 	bl	80014d0 <chOQWriteTimeout>
 8001a6c:	4603      	mov	r3, r0
}
 8001a6e:	4618      	mov	r0, r3
 8001a70:	b005      	add	sp, #20
 8001a72:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a76:	bf00      	nop
 8001a78:	f3af 8000 	nop.w
 8001a7c:	f3af 8000 	nop.w

08001a80 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8001a80:	b500      	push	{lr}
 8001a82:	b085      	sub	sp, #20
 8001a84:	9003      	str	r0, [sp, #12]
 8001a86:	9102      	str	r1, [sp, #8]
 8001a88:	9201      	str	r2, [sp, #4]
 8001a8a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001a8c:	9b03      	ldr	r3, [sp, #12]
 8001a8e:	330c      	adds	r3, #12
 8001a90:	4618      	mov	r0, r3
 8001a92:	9902      	ldr	r1, [sp, #8]
 8001a94:	9a01      	ldr	r2, [sp, #4]
 8001a96:	9b00      	ldr	r3, [sp, #0]
 8001a98:	f7ff fc22 	bl	80012e0 <chIQReadTimeout>
 8001a9c:	4603      	mov	r3, r0
}
 8001a9e:	4618      	mov	r0, r3
 8001aa0:	b005      	add	sp, #20
 8001aa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001aa6:	bf00      	nop
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8001ab0:	b508      	push	{r3, lr}

  sd_lld_init();
 8001ab2:	f001 f97d 	bl	8002db0 <sd_lld_init>
}
 8001ab6:	bd08      	pop	{r3, pc}
 8001ab8:	f3af 8000 	nop.w
 8001abc:	f3af 8000 	nop.w

08001ac0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001ac0:	b500      	push	{lr}
 8001ac2:	b087      	sub	sp, #28
 8001ac4:	9005      	str	r0, [sp, #20]
 8001ac6:	9104      	str	r1, [sp, #16]
 8001ac8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8001aca:	9b05      	ldr	r3, [sp, #20]
 8001acc:	4a14      	ldr	r2, [pc, #80]	; (8001b20 <sdObjectInit+0x60>)
 8001ace:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8001ad0:	9b05      	ldr	r3, [sp, #20]
 8001ad2:	3304      	adds	r3, #4
 8001ad4:	4618      	mov	r0, r3
 8001ad6:	f7ff ff1b 	bl	8001910 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8001ada:	9b05      	ldr	r3, [sp, #20]
 8001adc:	2201      	movs	r2, #1
 8001ade:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001ae0:	9b05      	ldr	r3, [sp, #20]
 8001ae2:	f103 010c 	add.w	r1, r3, #12
 8001ae6:	9b05      	ldr	r3, [sp, #20]
 8001ae8:	f103 0254 	add.w	r2, r3, #84	; 0x54
 8001aec:	9b05      	ldr	r3, [sp, #20]
 8001aee:	9300      	str	r3, [sp, #0]
 8001af0:	4608      	mov	r0, r1
 8001af2:	4611      	mov	r1, r2
 8001af4:	2210      	movs	r2, #16
 8001af6:	9b04      	ldr	r3, [sp, #16]
 8001af8:	f7ff fb52 	bl	80011a0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8001afc:	9b05      	ldr	r3, [sp, #20]
 8001afe:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8001b02:	9b05      	ldr	r3, [sp, #20]
 8001b04:	f103 0264 	add.w	r2, r3, #100	; 0x64
 8001b08:	9b05      	ldr	r3, [sp, #20]
 8001b0a:	9300      	str	r3, [sp, #0]
 8001b0c:	4608      	mov	r0, r1
 8001b0e:	4611      	mov	r1, r2
 8001b10:	2210      	movs	r2, #16
 8001b12:	9b03      	ldr	r3, [sp, #12]
 8001b14:	f7ff fc3c 	bl	8001390 <chOQObjectInit>
}
 8001b18:	b007      	add	sp, #28
 8001b1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b1e:	bf00      	nop
 8001b20:	08002fe0 	.word	0x08002fe0
 8001b24:	f3af 8000 	nop.w
 8001b28:	f3af 8000 	nop.w
 8001b2c:	f3af 8000 	nop.w

08001b30 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001b30:	b500      	push	{lr}
 8001b32:	b083      	sub	sp, #12
 8001b34:	9001      	str	r0, [sp, #4]
 8001b36:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8001b38:	f7ff feda 	bl	80018f0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8001b3c:	9801      	ldr	r0, [sp, #4]
 8001b3e:	9900      	ldr	r1, [sp, #0]
 8001b40:	f001 f946 	bl	8002dd0 <sd_lld_start>
  sdp->state = SD_READY;
 8001b44:	9b01      	ldr	r3, [sp, #4]
 8001b46:	2202      	movs	r2, #2
 8001b48:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8001b4a:	f7ff fed9 	bl	8001900 <osalSysUnlock>
}
 8001b4e:	b003      	add	sp, #12
 8001b50:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b54:	f3af 8000 	nop.w
 8001b58:	f3af 8000 	nop.w
 8001b5c:	f3af 8000 	nop.w

08001b60 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001b60:	b500      	push	{lr}
 8001b62:	b083      	sub	sp, #12
 8001b64:	9001      	str	r0, [sp, #4]
 8001b66:	460b      	mov	r3, r1
 8001b68:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001b6c:	9b01      	ldr	r3, [sp, #4]
 8001b6e:	330c      	adds	r3, #12
 8001b70:	4618      	mov	r0, r3
 8001b72:	f7ff fead 	bl	80018d0 <chIQIsEmptyI>
 8001b76:	4603      	mov	r3, r0
 8001b78:	2b00      	cmp	r3, #0
 8001b7a:	d005      	beq.n	8001b88 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8001b7c:	9b01      	ldr	r3, [sp, #4]
 8001b7e:	3304      	adds	r3, #4
 8001b80:	4618      	mov	r0, r3
 8001b82:	2104      	movs	r1, #4
 8001b84:	f7ff fed4 	bl	8001930 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8001b88:	9b01      	ldr	r3, [sp, #4]
 8001b8a:	f103 020c 	add.w	r2, r3, #12
 8001b8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001b92:	4610      	mov	r0, r2
 8001b94:	4619      	mov	r1, r3
 8001b96:	f7ff fb2b 	bl	80011f0 <chIQPutI>
 8001b9a:	4603      	mov	r3, r0
 8001b9c:	2b00      	cmp	r3, #0
 8001b9e:	da05      	bge.n	8001bac <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8001ba0:	9b01      	ldr	r3, [sp, #4]
 8001ba2:	3304      	adds	r3, #4
 8001ba4:	4618      	mov	r0, r3
 8001ba6:	2180      	movs	r1, #128	; 0x80
 8001ba8:	f7ff fec2 	bl	8001930 <osalEventBroadcastFlagsI>
}
 8001bac:	b003      	add	sp, #12
 8001bae:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bb2:	bf00      	nop
 8001bb4:	f3af 8000 	nop.w
 8001bb8:	f3af 8000 	nop.w
 8001bbc:	f3af 8000 	nop.w

08001bc0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b083      	sub	sp, #12
 8001bc4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001bc6:	9801      	ldr	r0, [sp, #4]
 8001bc8:	f7ff f9ea 	bl	8000fa0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 8001bcc:	b003      	add	sp, #12
 8001bce:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bd2:	bf00      	nop
 8001bd4:	f3af 8000 	nop.w
 8001bd8:	f3af 8000 	nop.w
 8001bdc:	f3af 8000 	nop.w

08001be0 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8001be0:	b508      	push	{r3, lr}

  spi_lld_init();
 8001be2:	f000 fe4d 	bl	8002880 <spi_lld_init>
}
 8001be6:	bd08      	pop	{r3, pc}
 8001be8:	f3af 8000 	nop.w
 8001bec:	f3af 8000 	nop.w

08001bf0 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8001bf0:	b500      	push	{lr}
 8001bf2:	b083      	sub	sp, #12
 8001bf4:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 8001bf6:	9b01      	ldr	r3, [sp, #4]
 8001bf8:	2201      	movs	r2, #1
 8001bfa:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 8001bfc:	9b01      	ldr	r3, [sp, #4]
 8001bfe:	2200      	movs	r2, #0
 8001c00:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8001c02:	9b01      	ldr	r3, [sp, #4]
 8001c04:	2200      	movs	r2, #0
 8001c06:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 8001c08:	9b01      	ldr	r3, [sp, #4]
 8001c0a:	330c      	adds	r3, #12
 8001c0c:	4618      	mov	r0, r3
 8001c0e:	f7ff ffd7 	bl	8001bc0 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8001c12:	b003      	add	sp, #12
 8001c14:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c18:	f3af 8000 	nop.w
 8001c1c:	f3af 8000 	nop.w

08001c20 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001c20:	b082      	sub	sp, #8
 8001c22:	9001      	str	r0, [sp, #4]
 8001c24:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8001c26:	4a12      	ldr	r2, [pc, #72]	; (8001c70 <nvicEnableVector+0x50>)
 8001c28:	9b00      	ldr	r3, [sp, #0]
 8001c2a:	b2db      	uxtb	r3, r3
 8001c2c:	011b      	lsls	r3, r3, #4
 8001c2e:	b2d9      	uxtb	r1, r3
 8001c30:	9b01      	ldr	r3, [sp, #4]
 8001c32:	4413      	add	r3, r2
 8001c34:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8001c38:	460a      	mov	r2, r1
 8001c3a:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8001c3c:	490c      	ldr	r1, [pc, #48]	; (8001c70 <nvicEnableVector+0x50>)
 8001c3e:	9b01      	ldr	r3, [sp, #4]
 8001c40:	095b      	lsrs	r3, r3, #5
 8001c42:	9a01      	ldr	r2, [sp, #4]
 8001c44:	f002 021f 	and.w	r2, r2, #31
 8001c48:	2001      	movs	r0, #1
 8001c4a:	fa00 f202 	lsl.w	r2, r0, r2
 8001c4e:	3360      	adds	r3, #96	; 0x60
 8001c50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8001c54:	4906      	ldr	r1, [pc, #24]	; (8001c70 <nvicEnableVector+0x50>)
 8001c56:	9b01      	ldr	r3, [sp, #4]
 8001c58:	095b      	lsrs	r3, r3, #5
 8001c5a:	9a01      	ldr	r2, [sp, #4]
 8001c5c:	f002 021f 	and.w	r2, r2, #31
 8001c60:	2001      	movs	r0, #1
 8001c62:	fa00 f202 	lsl.w	r2, r0, r2
 8001c66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8001c6a:	b002      	add	sp, #8
 8001c6c:	4770      	bx	lr
 8001c6e:	bf00      	nop
 8001c70:	e000e100 	.word	0xe000e100
 8001c74:	f3af 8000 	nop.w
 8001c78:	f3af 8000 	nop.w
 8001c7c:	f3af 8000 	nop.w

08001c80 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8001c80:	b082      	sub	sp, #8
 8001c82:	9001      	str	r0, [sp, #4]
 8001c84:	9100      	str	r1, [sp, #0]

  osalDbgCheck(handler <= 12);

  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 8001c86:	4a06      	ldr	r2, [pc, #24]	; (8001ca0 <nvicSetSystemHandlerPriority+0x20>)
 8001c88:	9b00      	ldr	r3, [sp, #0]
 8001c8a:	b2db      	uxtb	r3, r3
 8001c8c:	011b      	lsls	r3, r3, #4
 8001c8e:	b2d9      	uxtb	r1, r3
 8001c90:	9b01      	ldr	r3, [sp, #4]
 8001c92:	4413      	add	r3, r2
 8001c94:	3318      	adds	r3, #24
 8001c96:	460a      	mov	r2, r1
 8001c98:	701a      	strb	r2, [r3, #0]
}
 8001c9a:	b002      	add	sp, #8
 8001c9c:	4770      	bx	lr
 8001c9e:	bf00      	nop
 8001ca0:	e000ed00 	.word	0xe000ed00
 8001ca4:	f3af 8000 	nop.w
 8001ca8:	f3af 8000 	nop.w
 8001cac:	f3af 8000 	nop.w

08001cb0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8001cb0:	b500      	push	{lr}
 8001cb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8001cb4:	4b0b      	ldr	r3, [pc, #44]	; (8001ce4 <Vector6C+0x34>)
 8001cb6:	681b      	ldr	r3, [r3, #0]
 8001cb8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001cbc:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0;
 8001cbe:	4a09      	ldr	r2, [pc, #36]	; (8001ce4 <Vector6C+0x34>)
 8001cc0:	9b01      	ldr	r3, [sp, #4]
 8001cc2:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8001cc4:	4b08      	ldr	r3, [pc, #32]	; (8001ce8 <Vector6C+0x38>)
 8001cc6:	681b      	ldr	r3, [r3, #0]
 8001cc8:	2b00      	cmp	r3, #0
 8001cca:	d006      	beq.n	8001cda <Vector6C+0x2a>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8001ccc:	4b06      	ldr	r3, [pc, #24]	; (8001ce8 <Vector6C+0x38>)
 8001cce:	681b      	ldr	r3, [r3, #0]
 8001cd0:	4a05      	ldr	r2, [pc, #20]	; (8001ce8 <Vector6C+0x38>)
 8001cd2:	6852      	ldr	r2, [r2, #4]
 8001cd4:	4610      	mov	r0, r2
 8001cd6:	9901      	ldr	r1, [sp, #4]
 8001cd8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001cda:	f7ff fd19 	bl	8001710 <_port_irq_epilogue>
}
 8001cde:	b003      	add	sp, #12
 8001ce0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ce4:	40026000 	.word	0x40026000
 8001ce8:	20000a04 	.word	0x20000a04
 8001cec:	f3af 8000 	nop.w

08001cf0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 8001cf0:	b500      	push	{lr}
 8001cf2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8001cf4:	4b0c      	ldr	r3, [pc, #48]	; (8001d28 <Vector70+0x38>)
 8001cf6:	681b      	ldr	r3, [r3, #0]
 8001cf8:	099b      	lsrs	r3, r3, #6
 8001cfa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001cfe:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6;
 8001d00:	4a09      	ldr	r2, [pc, #36]	; (8001d28 <Vector70+0x38>)
 8001d02:	9b01      	ldr	r3, [sp, #4]
 8001d04:	019b      	lsls	r3, r3, #6
 8001d06:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 8001d08:	4b08      	ldr	r3, [pc, #32]	; (8001d2c <Vector70+0x3c>)
 8001d0a:	689b      	ldr	r3, [r3, #8]
 8001d0c:	2b00      	cmp	r3, #0
 8001d0e:	d006      	beq.n	8001d1e <Vector70+0x2e>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8001d10:	4b06      	ldr	r3, [pc, #24]	; (8001d2c <Vector70+0x3c>)
 8001d12:	689b      	ldr	r3, [r3, #8]
 8001d14:	4a05      	ldr	r2, [pc, #20]	; (8001d2c <Vector70+0x3c>)
 8001d16:	68d2      	ldr	r2, [r2, #12]
 8001d18:	4610      	mov	r0, r2
 8001d1a:	9901      	ldr	r1, [sp, #4]
 8001d1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001d1e:	f7ff fcf7 	bl	8001710 <_port_irq_epilogue>
}
 8001d22:	b003      	add	sp, #12
 8001d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d28:	40026000 	.word	0x40026000
 8001d2c:	20000a04 	.word	0x20000a04

08001d30 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 8001d30:	b500      	push	{lr}
 8001d32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001d34:	4b0c      	ldr	r3, [pc, #48]	; (8001d68 <Vector74+0x38>)
 8001d36:	681b      	ldr	r3, [r3, #0]
 8001d38:	0c1b      	lsrs	r3, r3, #16
 8001d3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001d3e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16;
 8001d40:	4a09      	ldr	r2, [pc, #36]	; (8001d68 <Vector74+0x38>)
 8001d42:	9b01      	ldr	r3, [sp, #4]
 8001d44:	041b      	lsls	r3, r3, #16
 8001d46:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8001d48:	4b08      	ldr	r3, [pc, #32]	; (8001d6c <Vector74+0x3c>)
 8001d4a:	691b      	ldr	r3, [r3, #16]
 8001d4c:	2b00      	cmp	r3, #0
 8001d4e:	d006      	beq.n	8001d5e <Vector74+0x2e>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8001d50:	4b06      	ldr	r3, [pc, #24]	; (8001d6c <Vector74+0x3c>)
 8001d52:	691b      	ldr	r3, [r3, #16]
 8001d54:	4a05      	ldr	r2, [pc, #20]	; (8001d6c <Vector74+0x3c>)
 8001d56:	6952      	ldr	r2, [r2, #20]
 8001d58:	4610      	mov	r0, r2
 8001d5a:	9901      	ldr	r1, [sp, #4]
 8001d5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001d5e:	f7ff fcd7 	bl	8001710 <_port_irq_epilogue>
}
 8001d62:	b003      	add	sp, #12
 8001d64:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d68:	40026000 	.word	0x40026000
 8001d6c:	20000a04 	.word	0x20000a04

08001d70 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 8001d70:	b500      	push	{lr}
 8001d72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001d74:	4b0c      	ldr	r3, [pc, #48]	; (8001da8 <Vector78+0x38>)
 8001d76:	681b      	ldr	r3, [r3, #0]
 8001d78:	0d9b      	lsrs	r3, r3, #22
 8001d7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001d7e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22;
 8001d80:	4a09      	ldr	r2, [pc, #36]	; (8001da8 <Vector78+0x38>)
 8001d82:	9b01      	ldr	r3, [sp, #4]
 8001d84:	059b      	lsls	r3, r3, #22
 8001d86:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8001d88:	4b08      	ldr	r3, [pc, #32]	; (8001dac <Vector78+0x3c>)
 8001d8a:	699b      	ldr	r3, [r3, #24]
 8001d8c:	2b00      	cmp	r3, #0
 8001d8e:	d006      	beq.n	8001d9e <Vector78+0x2e>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8001d90:	4b06      	ldr	r3, [pc, #24]	; (8001dac <Vector78+0x3c>)
 8001d92:	699b      	ldr	r3, [r3, #24]
 8001d94:	4a05      	ldr	r2, [pc, #20]	; (8001dac <Vector78+0x3c>)
 8001d96:	69d2      	ldr	r2, [r2, #28]
 8001d98:	4610      	mov	r0, r2
 8001d9a:	9901      	ldr	r1, [sp, #4]
 8001d9c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001d9e:	f7ff fcb7 	bl	8001710 <_port_irq_epilogue>
}
 8001da2:	b003      	add	sp, #12
 8001da4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001da8:	40026000 	.word	0x40026000
 8001dac:	20000a04 	.word	0x20000a04

08001db0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 8001db0:	b500      	push	{lr}
 8001db2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001db4:	4b0b      	ldr	r3, [pc, #44]	; (8001de4 <Vector7C+0x34>)
 8001db6:	685b      	ldr	r3, [r3, #4]
 8001db8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001dbc:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0;
 8001dbe:	4a09      	ldr	r2, [pc, #36]	; (8001de4 <Vector7C+0x34>)
 8001dc0:	9b01      	ldr	r3, [sp, #4]
 8001dc2:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 8001dc4:	4b08      	ldr	r3, [pc, #32]	; (8001de8 <Vector7C+0x38>)
 8001dc6:	6a1b      	ldr	r3, [r3, #32]
 8001dc8:	2b00      	cmp	r3, #0
 8001dca:	d006      	beq.n	8001dda <Vector7C+0x2a>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8001dcc:	4b06      	ldr	r3, [pc, #24]	; (8001de8 <Vector7C+0x38>)
 8001dce:	6a1b      	ldr	r3, [r3, #32]
 8001dd0:	4a05      	ldr	r2, [pc, #20]	; (8001de8 <Vector7C+0x38>)
 8001dd2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001dd4:	4610      	mov	r0, r2
 8001dd6:	9901      	ldr	r1, [sp, #4]
 8001dd8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001dda:	f7ff fc99 	bl	8001710 <_port_irq_epilogue>
}
 8001dde:	b003      	add	sp, #12
 8001de0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001de4:	40026000 	.word	0x40026000
 8001de8:	20000a04 	.word	0x20000a04
 8001dec:	f3af 8000 	nop.w

08001df0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 8001df0:	b500      	push	{lr}
 8001df2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001df4:	4b0c      	ldr	r3, [pc, #48]	; (8001e28 <Vector80+0x38>)
 8001df6:	685b      	ldr	r3, [r3, #4]
 8001df8:	099b      	lsrs	r3, r3, #6
 8001dfa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001dfe:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6;
 8001e00:	4a09      	ldr	r2, [pc, #36]	; (8001e28 <Vector80+0x38>)
 8001e02:	9b01      	ldr	r3, [sp, #4]
 8001e04:	019b      	lsls	r3, r3, #6
 8001e06:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 8001e08:	4b08      	ldr	r3, [pc, #32]	; (8001e2c <Vector80+0x3c>)
 8001e0a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e0c:	2b00      	cmp	r3, #0
 8001e0e:	d006      	beq.n	8001e1e <Vector80+0x2e>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8001e10:	4b06      	ldr	r3, [pc, #24]	; (8001e2c <Vector80+0x3c>)
 8001e12:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e14:	4a05      	ldr	r2, [pc, #20]	; (8001e2c <Vector80+0x3c>)
 8001e16:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001e18:	4610      	mov	r0, r2
 8001e1a:	9901      	ldr	r1, [sp, #4]
 8001e1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001e1e:	f7ff fc77 	bl	8001710 <_port_irq_epilogue>
}
 8001e22:	b003      	add	sp, #12
 8001e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e28:	40026000 	.word	0x40026000
 8001e2c:	20000a04 	.word	0x20000a04

08001e30 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 8001e30:	b500      	push	{lr}
 8001e32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001e34:	4b0c      	ldr	r3, [pc, #48]	; (8001e68 <Vector84+0x38>)
 8001e36:	685b      	ldr	r3, [r3, #4]
 8001e38:	0c1b      	lsrs	r3, r3, #16
 8001e3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001e3e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16;
 8001e40:	4a09      	ldr	r2, [pc, #36]	; (8001e68 <Vector84+0x38>)
 8001e42:	9b01      	ldr	r3, [sp, #4]
 8001e44:	041b      	lsls	r3, r3, #16
 8001e46:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8001e48:	4b08      	ldr	r3, [pc, #32]	; (8001e6c <Vector84+0x3c>)
 8001e4a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001e4c:	2b00      	cmp	r3, #0
 8001e4e:	d006      	beq.n	8001e5e <Vector84+0x2e>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8001e50:	4b06      	ldr	r3, [pc, #24]	; (8001e6c <Vector84+0x3c>)
 8001e52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001e54:	4a05      	ldr	r2, [pc, #20]	; (8001e6c <Vector84+0x3c>)
 8001e56:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8001e58:	4610      	mov	r0, r2
 8001e5a:	9901      	ldr	r1, [sp, #4]
 8001e5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001e5e:	f7ff fc57 	bl	8001710 <_port_irq_epilogue>
}
 8001e62:	b003      	add	sp, #12
 8001e64:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e68:	40026000 	.word	0x40026000
 8001e6c:	20000a04 	.word	0x20000a04

08001e70 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 8001e70:	b500      	push	{lr}
 8001e72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001e74:	4b0c      	ldr	r3, [pc, #48]	; (8001ea8 <VectorFC+0x38>)
 8001e76:	685b      	ldr	r3, [r3, #4]
 8001e78:	0d9b      	lsrs	r3, r3, #22
 8001e7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001e7e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22;
 8001e80:	4a09      	ldr	r2, [pc, #36]	; (8001ea8 <VectorFC+0x38>)
 8001e82:	9b01      	ldr	r3, [sp, #4]
 8001e84:	059b      	lsls	r3, r3, #22
 8001e86:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 8001e88:	4b08      	ldr	r3, [pc, #32]	; (8001eac <VectorFC+0x3c>)
 8001e8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001e8c:	2b00      	cmp	r3, #0
 8001e8e:	d006      	beq.n	8001e9e <VectorFC+0x2e>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8001e90:	4b06      	ldr	r3, [pc, #24]	; (8001eac <VectorFC+0x3c>)
 8001e92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001e94:	4a05      	ldr	r2, [pc, #20]	; (8001eac <VectorFC+0x3c>)
 8001e96:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8001e98:	4610      	mov	r0, r2
 8001e9a:	9901      	ldr	r1, [sp, #4]
 8001e9c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001e9e:	f7ff fc37 	bl	8001710 <_port_irq_epilogue>
}
 8001ea2:	b003      	add	sp, #12
 8001ea4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ea8:	40026000 	.word	0x40026000
 8001eac:	20000a04 	.word	0x20000a04

08001eb0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8001eb0:	b500      	push	{lr}
 8001eb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8001eb4:	4b0b      	ldr	r3, [pc, #44]	; (8001ee4 <Vector120+0x34>)
 8001eb6:	681b      	ldr	r3, [r3, #0]
 8001eb8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001ebc:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0;
 8001ebe:	4a09      	ldr	r2, [pc, #36]	; (8001ee4 <Vector120+0x34>)
 8001ec0:	9b01      	ldr	r3, [sp, #4]
 8001ec2:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 8001ec4:	4b08      	ldr	r3, [pc, #32]	; (8001ee8 <Vector120+0x38>)
 8001ec6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ec8:	2b00      	cmp	r3, #0
 8001eca:	d006      	beq.n	8001eda <Vector120+0x2a>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8001ecc:	4b06      	ldr	r3, [pc, #24]	; (8001ee8 <Vector120+0x38>)
 8001ece:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ed0:	4a05      	ldr	r2, [pc, #20]	; (8001ee8 <Vector120+0x38>)
 8001ed2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8001ed4:	4610      	mov	r0, r2
 8001ed6:	9901      	ldr	r1, [sp, #4]
 8001ed8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001eda:	f7ff fc19 	bl	8001710 <_port_irq_epilogue>
}
 8001ede:	b003      	add	sp, #12
 8001ee0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ee4:	40026400 	.word	0x40026400
 8001ee8:	20000a04 	.word	0x20000a04
 8001eec:	f3af 8000 	nop.w

08001ef0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8001ef4:	4b0c      	ldr	r3, [pc, #48]	; (8001f28 <Vector124+0x38>)
 8001ef6:	681b      	ldr	r3, [r3, #0]
 8001ef8:	099b      	lsrs	r3, r3, #6
 8001efa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001efe:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6;
 8001f00:	4a09      	ldr	r2, [pc, #36]	; (8001f28 <Vector124+0x38>)
 8001f02:	9b01      	ldr	r3, [sp, #4]
 8001f04:	019b      	lsls	r3, r3, #6
 8001f06:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 8001f08:	4b08      	ldr	r3, [pc, #32]	; (8001f2c <Vector124+0x3c>)
 8001f0a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001f0c:	2b00      	cmp	r3, #0
 8001f0e:	d006      	beq.n	8001f1e <Vector124+0x2e>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8001f10:	4b06      	ldr	r3, [pc, #24]	; (8001f2c <Vector124+0x3c>)
 8001f12:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001f14:	4a05      	ldr	r2, [pc, #20]	; (8001f2c <Vector124+0x3c>)
 8001f16:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8001f18:	4610      	mov	r0, r2
 8001f1a:	9901      	ldr	r1, [sp, #4]
 8001f1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001f1e:	f7ff fbf7 	bl	8001710 <_port_irq_epilogue>
}
 8001f22:	b003      	add	sp, #12
 8001f24:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f28:	40026400 	.word	0x40026400
 8001f2c:	20000a04 	.word	0x20000a04

08001f30 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 8001f30:	b500      	push	{lr}
 8001f32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001f34:	4b0c      	ldr	r3, [pc, #48]	; (8001f68 <Vector128+0x38>)
 8001f36:	681b      	ldr	r3, [r3, #0]
 8001f38:	0c1b      	lsrs	r3, r3, #16
 8001f3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001f3e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16;
 8001f40:	4a09      	ldr	r2, [pc, #36]	; (8001f68 <Vector128+0x38>)
 8001f42:	9b01      	ldr	r3, [sp, #4]
 8001f44:	041b      	lsls	r3, r3, #16
 8001f46:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 8001f48:	4b08      	ldr	r3, [pc, #32]	; (8001f6c <Vector128+0x3c>)
 8001f4a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001f4c:	2b00      	cmp	r3, #0
 8001f4e:	d006      	beq.n	8001f5e <Vector128+0x2e>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8001f50:	4b06      	ldr	r3, [pc, #24]	; (8001f6c <Vector128+0x3c>)
 8001f52:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001f54:	4a05      	ldr	r2, [pc, #20]	; (8001f6c <Vector128+0x3c>)
 8001f56:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8001f58:	4610      	mov	r0, r2
 8001f5a:	9901      	ldr	r1, [sp, #4]
 8001f5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001f5e:	f7ff fbd7 	bl	8001710 <_port_irq_epilogue>
}
 8001f62:	b003      	add	sp, #12
 8001f64:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f68:	40026400 	.word	0x40026400
 8001f6c:	20000a04 	.word	0x20000a04

08001f70 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 8001f70:	b500      	push	{lr}
 8001f72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001f74:	4b0c      	ldr	r3, [pc, #48]	; (8001fa8 <Vector12C+0x38>)
 8001f76:	681b      	ldr	r3, [r3, #0]
 8001f78:	0d9b      	lsrs	r3, r3, #22
 8001f7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001f7e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22;
 8001f80:	4a09      	ldr	r2, [pc, #36]	; (8001fa8 <Vector12C+0x38>)
 8001f82:	9b01      	ldr	r3, [sp, #4]
 8001f84:	059b      	lsls	r3, r3, #22
 8001f86:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 8001f88:	4b08      	ldr	r3, [pc, #32]	; (8001fac <Vector12C+0x3c>)
 8001f8a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001f8c:	2b00      	cmp	r3, #0
 8001f8e:	d006      	beq.n	8001f9e <Vector12C+0x2e>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8001f90:	4b06      	ldr	r3, [pc, #24]	; (8001fac <Vector12C+0x3c>)
 8001f92:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001f94:	4a05      	ldr	r2, [pc, #20]	; (8001fac <Vector12C+0x3c>)
 8001f96:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8001f98:	4610      	mov	r0, r2
 8001f9a:	9901      	ldr	r1, [sp, #4]
 8001f9c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001f9e:	f7ff fbb7 	bl	8001710 <_port_irq_epilogue>
}
 8001fa2:	b003      	add	sp, #12
 8001fa4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fa8:	40026400 	.word	0x40026400
 8001fac:	20000a04 	.word	0x20000a04

08001fb0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8001fb0:	b500      	push	{lr}
 8001fb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001fb4:	4b0b      	ldr	r3, [pc, #44]	; (8001fe4 <Vector130+0x34>)
 8001fb6:	685b      	ldr	r3, [r3, #4]
 8001fb8:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001fbc:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0;
 8001fbe:	4a09      	ldr	r2, [pc, #36]	; (8001fe4 <Vector130+0x34>)
 8001fc0:	9b01      	ldr	r3, [sp, #4]
 8001fc2:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 8001fc4:	4b08      	ldr	r3, [pc, #32]	; (8001fe8 <Vector130+0x38>)
 8001fc6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001fc8:	2b00      	cmp	r3, #0
 8001fca:	d006      	beq.n	8001fda <Vector130+0x2a>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8001fcc:	4b06      	ldr	r3, [pc, #24]	; (8001fe8 <Vector130+0x38>)
 8001fce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001fd0:	4a05      	ldr	r2, [pc, #20]	; (8001fe8 <Vector130+0x38>)
 8001fd2:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8001fd4:	4610      	mov	r0, r2
 8001fd6:	9901      	ldr	r1, [sp, #4]
 8001fd8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001fda:	f7ff fb99 	bl	8001710 <_port_irq_epilogue>
}
 8001fde:	b003      	add	sp, #12
 8001fe0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fe4:	40026400 	.word	0x40026400
 8001fe8:	20000a04 	.word	0x20000a04
 8001fec:	f3af 8000 	nop.w

08001ff0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001ff4:	4b0c      	ldr	r3, [pc, #48]	; (8002028 <Vector150+0x38>)
 8001ff6:	685b      	ldr	r3, [r3, #4]
 8001ff8:	099b      	lsrs	r3, r3, #6
 8001ffa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001ffe:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6;
 8002000:	4a09      	ldr	r2, [pc, #36]	; (8002028 <Vector150+0x38>)
 8002002:	9b01      	ldr	r3, [sp, #4]
 8002004:	019b      	lsls	r3, r3, #6
 8002006:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 8002008:	4b08      	ldr	r3, [pc, #32]	; (800202c <Vector150+0x3c>)
 800200a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800200c:	2b00      	cmp	r3, #0
 800200e:	d006      	beq.n	800201e <Vector150+0x2e>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8002010:	4b06      	ldr	r3, [pc, #24]	; (800202c <Vector150+0x3c>)
 8002012:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002014:	4a05      	ldr	r2, [pc, #20]	; (800202c <Vector150+0x3c>)
 8002016:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8002018:	4610      	mov	r0, r2
 800201a:	9901      	ldr	r1, [sp, #4]
 800201c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800201e:	f7ff fb77 	bl	8001710 <_port_irq_epilogue>
}
 8002022:	b003      	add	sp, #12
 8002024:	f85d fb04 	ldr.w	pc, [sp], #4
 8002028:	40026400 	.word	0x40026400
 800202c:	20000a04 	.word	0x20000a04

08002030 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 8002030:	b500      	push	{lr}
 8002032:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8002034:	4b0c      	ldr	r3, [pc, #48]	; (8002068 <Vector154+0x38>)
 8002036:	685b      	ldr	r3, [r3, #4]
 8002038:	0c1b      	lsrs	r3, r3, #16
 800203a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800203e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16;
 8002040:	4a09      	ldr	r2, [pc, #36]	; (8002068 <Vector154+0x38>)
 8002042:	9b01      	ldr	r3, [sp, #4]
 8002044:	041b      	lsls	r3, r3, #16
 8002046:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 8002048:	4b08      	ldr	r3, [pc, #32]	; (800206c <Vector154+0x3c>)
 800204a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800204c:	2b00      	cmp	r3, #0
 800204e:	d006      	beq.n	800205e <Vector154+0x2e>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8002050:	4b06      	ldr	r3, [pc, #24]	; (800206c <Vector154+0x3c>)
 8002052:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002054:	4a05      	ldr	r2, [pc, #20]	; (800206c <Vector154+0x3c>)
 8002056:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8002058:	4610      	mov	r0, r2
 800205a:	9901      	ldr	r1, [sp, #4]
 800205c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800205e:	f7ff fb57 	bl	8001710 <_port_irq_epilogue>
}
 8002062:	b003      	add	sp, #12
 8002064:	f85d fb04 	ldr.w	pc, [sp], #4
 8002068:	40026400 	.word	0x40026400
 800206c:	20000a04 	.word	0x20000a04

08002070 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 8002070:	b500      	push	{lr}
 8002072:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8002074:	4b0c      	ldr	r3, [pc, #48]	; (80020a8 <Vector158+0x38>)
 8002076:	685b      	ldr	r3, [r3, #4]
 8002078:	0d9b      	lsrs	r3, r3, #22
 800207a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800207e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22;
 8002080:	4a09      	ldr	r2, [pc, #36]	; (80020a8 <Vector158+0x38>)
 8002082:	9b01      	ldr	r3, [sp, #4]
 8002084:	059b      	lsls	r3, r3, #22
 8002086:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 8002088:	4b08      	ldr	r3, [pc, #32]	; (80020ac <Vector158+0x3c>)
 800208a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800208c:	2b00      	cmp	r3, #0
 800208e:	d006      	beq.n	800209e <Vector158+0x2e>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8002090:	4b06      	ldr	r3, [pc, #24]	; (80020ac <Vector158+0x3c>)
 8002092:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8002094:	4a05      	ldr	r2, [pc, #20]	; (80020ac <Vector158+0x3c>)
 8002096:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 8002098:	4610      	mov	r0, r2
 800209a:	9901      	ldr	r1, [sp, #4]
 800209c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800209e:	f7ff fb37 	bl	8001710 <_port_irq_epilogue>
}
 80020a2:	b003      	add	sp, #12
 80020a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80020a8:	40026400 	.word	0x40026400
 80020ac:	20000a04 	.word	0x20000a04

080020b0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 80020b0:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0;
 80020b2:	4b16      	ldr	r3, [pc, #88]	; (800210c <dmaInit+0x5c>)
 80020b4:	2200      	movs	r2, #0
 80020b6:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80020b8:	2300      	movs	r3, #0
 80020ba:	9301      	str	r3, [sp, #4]
 80020bc:	e011      	b.n	80020e2 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0;
 80020be:	4914      	ldr	r1, [pc, #80]	; (8002110 <dmaInit+0x60>)
 80020c0:	9a01      	ldr	r2, [sp, #4]
 80020c2:	4613      	mov	r3, r2
 80020c4:	005b      	lsls	r3, r3, #1
 80020c6:	4413      	add	r3, r2
 80020c8:	009b      	lsls	r3, r3, #2
 80020ca:	440b      	add	r3, r1
 80020cc:	681b      	ldr	r3, [r3, #0]
 80020ce:	2200      	movs	r2, #0
 80020d0:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 80020d2:	4a10      	ldr	r2, [pc, #64]	; (8002114 <dmaInit+0x64>)
 80020d4:	9b01      	ldr	r3, [sp, #4]
 80020d6:	2100      	movs	r1, #0
 80020d8:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80020dc:	9b01      	ldr	r3, [sp, #4]
 80020de:	3301      	adds	r3, #1
 80020e0:	9301      	str	r3, [sp, #4]
 80020e2:	9b01      	ldr	r3, [sp, #4]
 80020e4:	2b0f      	cmp	r3, #15
 80020e6:	ddea      	ble.n	80020be <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 80020e8:	4b0b      	ldr	r3, [pc, #44]	; (8002118 <dmaInit+0x68>)
 80020ea:	f04f 32ff 	mov.w	r2, #4294967295
 80020ee:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
 80020f0:	4b09      	ldr	r3, [pc, #36]	; (8002118 <dmaInit+0x68>)
 80020f2:	f04f 32ff 	mov.w	r2, #4294967295
 80020f6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 80020f8:	4b08      	ldr	r3, [pc, #32]	; (800211c <dmaInit+0x6c>)
 80020fa:	f04f 32ff 	mov.w	r2, #4294967295
 80020fe:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 8002100:	4b06      	ldr	r3, [pc, #24]	; (800211c <dmaInit+0x6c>)
 8002102:	f04f 32ff 	mov.w	r2, #4294967295
 8002106:	60da      	str	r2, [r3, #12]
}
 8002108:	b002      	add	sp, #8
 800210a:	4770      	bx	lr
 800210c:	20000a00 	.word	0x20000a00
 8002110:	08003000 	.word	0x08003000
 8002114:	20000a04 	.word	0x20000a04
 8002118:	40026000 	.word	0x40026000
 800211c:	40026400 	.word	0x40026400

08002120 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002120:	4a0d      	ldr	r2, [pc, #52]	; (8002158 <hal_lld_backup_domain_init+0x38>)
 8002122:	4b0d      	ldr	r3, [pc, #52]	; (8002158 <hal_lld_backup_domain_init+0x38>)
 8002124:	681b      	ldr	r3, [r3, #0]
 8002126:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800212a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800212c:	4b0b      	ldr	r3, [pc, #44]	; (800215c <hal_lld_backup_domain_init+0x3c>)
 800212e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002130:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8002134:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002138:	d006      	beq.n	8002148 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800213a:	4b08      	ldr	r3, [pc, #32]	; (800215c <hal_lld_backup_domain_init+0x3c>)
 800213c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8002140:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8002142:	4b06      	ldr	r3, [pc, #24]	; (800215c <hal_lld_backup_domain_init+0x3c>)
 8002144:	2200      	movs	r2, #0
 8002146:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8002148:	4a03      	ldr	r2, [pc, #12]	; (8002158 <hal_lld_backup_domain_init+0x38>)
 800214a:	4b03      	ldr	r3, [pc, #12]	; (8002158 <hal_lld_backup_domain_init+0x38>)
 800214c:	685b      	ldr	r3, [r3, #4]
 800214e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002152:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8002154:	4770      	bx	lr
 8002156:	bf00      	nop
 8002158:	40007000 	.word	0x40007000
 800215c:	40023800 	.word	0x40023800

08002160 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8002160:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8002162:	4b17      	ldr	r3, [pc, #92]	; (80021c0 <hal_lld_init+0x60>)
 8002164:	691b      	ldr	r3, [r3, #16]
 8002166:	4b16      	ldr	r3, [pc, #88]	; (80021c0 <hal_lld_init+0x60>)
 8002168:	f04f 32ff 	mov.w	r2, #4294967295
 800216c:	611a      	str	r2, [r3, #16]
 800216e:	4b14      	ldr	r3, [pc, #80]	; (80021c0 <hal_lld_init+0x60>)
 8002170:	2200      	movs	r2, #0
 8002172:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8002174:	4b12      	ldr	r3, [pc, #72]	; (80021c0 <hal_lld_init+0x60>)
 8002176:	695b      	ldr	r3, [r3, #20]
 8002178:	4b11      	ldr	r3, [pc, #68]	; (80021c0 <hal_lld_init+0x60>)
 800217a:	f04f 32ff 	mov.w	r2, #4294967295
 800217e:	615a      	str	r2, [r3, #20]
 8002180:	4b0f      	ldr	r3, [pc, #60]	; (80021c0 <hal_lld_init+0x60>)
 8002182:	2200      	movs	r2, #0
 8002184:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8002186:	4a0e      	ldr	r2, [pc, #56]	; (80021c0 <hal_lld_init+0x60>)
 8002188:	4b0d      	ldr	r3, [pc, #52]	; (80021c0 <hal_lld_init+0x60>)
 800218a:	6a1b      	ldr	r3, [r3, #32]
 800218c:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8002190:	6213      	str	r3, [r2, #32]
 8002192:	4b0b      	ldr	r3, [pc, #44]	; (80021c0 <hal_lld_init+0x60>)
 8002194:	2200      	movs	r2, #0
 8002196:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8002198:	4b09      	ldr	r3, [pc, #36]	; (80021c0 <hal_lld_init+0x60>)
 800219a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800219c:	4b08      	ldr	r3, [pc, #32]	; (80021c0 <hal_lld_init+0x60>)
 800219e:	f04f 32ff 	mov.w	r2, #4294967295
 80021a2:	625a      	str	r2, [r3, #36]	; 0x24
 80021a4:	4b06      	ldr	r3, [pc, #24]	; (80021c0 <hal_lld_init+0x60>)
 80021a6:	2200      	movs	r2, #0
 80021a8:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80021aa:	4a05      	ldr	r2, [pc, #20]	; (80021c0 <hal_lld_init+0x60>)
 80021ac:	4b04      	ldr	r3, [pc, #16]	; (80021c0 <hal_lld_init+0x60>)
 80021ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021b0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80021b4:	6413      	str	r3, [r2, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80021b6:	f7ff ffb3 	bl	8002120 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 80021ba:	f7ff ff79 	bl	80020b0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80021be:	bd08      	pop	{r3, pc}
 80021c0:	40023800 	.word	0x40023800
 80021c4:	f3af 8000 	nop.w
 80021c8:	f3af 8000 	nop.w
 80021cc:	f3af 8000 	nop.w

080021d0 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80021d0:	4b40      	ldr	r3, [pc, #256]	; (80022d4 <stm32_clock_init+0x104>)
 80021d2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80021d6:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80021d8:	4b3f      	ldr	r3, [pc, #252]	; (80022d8 <stm32_clock_init+0x108>)
 80021da:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 80021de:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80021e0:	4a3c      	ldr	r2, [pc, #240]	; (80022d4 <stm32_clock_init+0x104>)
 80021e2:	4b3c      	ldr	r3, [pc, #240]	; (80022d4 <stm32_clock_init+0x104>)
 80021e4:	681b      	ldr	r3, [r3, #0]
 80021e6:	f043 0301 	orr.w	r3, r3, #1
 80021ea:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80021ec:	bf00      	nop
 80021ee:	4b39      	ldr	r3, [pc, #228]	; (80022d4 <stm32_clock_init+0x104>)
 80021f0:	681b      	ldr	r3, [r3, #0]
 80021f2:	f003 0302 	and.w	r3, r3, #2
 80021f6:	2b00      	cmp	r3, #0
 80021f8:	d0f9      	beq.n	80021ee <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80021fa:	4a36      	ldr	r2, [pc, #216]	; (80022d4 <stm32_clock_init+0x104>)
 80021fc:	4b35      	ldr	r3, [pc, #212]	; (80022d4 <stm32_clock_init+0x104>)
 80021fe:	689b      	ldr	r3, [r3, #8]
 8002200:	f023 0303 	bic.w	r3, r3, #3
 8002204:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8002206:	4a33      	ldr	r2, [pc, #204]	; (80022d4 <stm32_clock_init+0x104>)
 8002208:	4b32      	ldr	r3, [pc, #200]	; (80022d4 <stm32_clock_init+0x104>)
 800220a:	689b      	ldr	r3, [r3, #8]
 800220c:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800220e:	bf00      	nop
 8002210:	4b30      	ldr	r3, [pc, #192]	; (80022d4 <stm32_clock_init+0x104>)
 8002212:	689b      	ldr	r3, [r3, #8]
 8002214:	f003 030c 	and.w	r3, r3, #12
 8002218:	2b00      	cmp	r3, #0
 800221a:	d1f9      	bne.n	8002210 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800221c:	4a2d      	ldr	r2, [pc, #180]	; (80022d4 <stm32_clock_init+0x104>)
 800221e:	4b2d      	ldr	r3, [pc, #180]	; (80022d4 <stm32_clock_init+0x104>)
 8002220:	681b      	ldr	r3, [r3, #0]
 8002222:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8002226:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8002228:	4b2a      	ldr	r3, [pc, #168]	; (80022d4 <stm32_clock_init+0x104>)
 800222a:	2200      	movs	r2, #0
 800222c:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800222e:	4a29      	ldr	r2, [pc, #164]	; (80022d4 <stm32_clock_init+0x104>)
 8002230:	4b28      	ldr	r3, [pc, #160]	; (80022d4 <stm32_clock_init+0x104>)
 8002232:	681b      	ldr	r3, [r3, #0]
 8002234:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002238:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800223a:	bf00      	nop
 800223c:	4b25      	ldr	r3, [pc, #148]	; (80022d4 <stm32_clock_init+0x104>)
 800223e:	681b      	ldr	r3, [r3, #0]
 8002240:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002244:	2b00      	cmp	r3, #0
 8002246:	d0f9      	beq.n	800223c <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8002248:	4a22      	ldr	r2, [pc, #136]	; (80022d4 <stm32_clock_init+0x104>)
 800224a:	4b22      	ldr	r3, [pc, #136]	; (80022d4 <stm32_clock_init+0x104>)
 800224c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800224e:	f043 0301 	orr.w	r3, r3, #1
 8002252:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002254:	bf00      	nop
 8002256:	4b1f      	ldr	r3, [pc, #124]	; (80022d4 <stm32_clock_init+0x104>)
 8002258:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800225a:	f003 0302 	and.w	r3, r3, #2
 800225e:	2b00      	cmp	r3, #0
 8002260:	d0f9      	beq.n	8002256 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8002262:	4b1c      	ldr	r3, [pc, #112]	; (80022d4 <stm32_clock_init+0x104>)
 8002264:	4a1d      	ldr	r2, [pc, #116]	; (80022dc <stm32_clock_init+0x10c>)
 8002266:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8002268:	4a1a      	ldr	r2, [pc, #104]	; (80022d4 <stm32_clock_init+0x104>)
 800226a:	4b1a      	ldr	r3, [pc, #104]	; (80022d4 <stm32_clock_init+0x104>)
 800226c:	681b      	ldr	r3, [r3, #0]
 800226e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002272:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8002274:	bf00      	nop
 8002276:	4b18      	ldr	r3, [pc, #96]	; (80022d8 <stm32_clock_init+0x108>)
 8002278:	685b      	ldr	r3, [r3, #4]
 800227a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800227e:	2b00      	cmp	r3, #0
 8002280:	d0f9      	beq.n	8002276 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002282:	bf00      	nop
 8002284:	4b13      	ldr	r3, [pc, #76]	; (80022d4 <stm32_clock_init+0x104>)
 8002286:	681b      	ldr	r3, [r3, #0]
 8002288:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800228c:	2b00      	cmp	r3, #0
 800228e:	d0f9      	beq.n	8002284 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8002290:	4b10      	ldr	r3, [pc, #64]	; (80022d4 <stm32_clock_init+0x104>)
 8002292:	4a13      	ldr	r2, [pc, #76]	; (80022e0 <stm32_clock_init+0x110>)
 8002294:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8002296:	4b13      	ldr	r3, [pc, #76]	; (80022e4 <stm32_clock_init+0x114>)
 8002298:	f240 7205 	movw	r2, #1797	; 0x705
 800229c:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800229e:	4a0d      	ldr	r2, [pc, #52]	; (80022d4 <stm32_clock_init+0x104>)
 80022a0:	4b0c      	ldr	r3, [pc, #48]	; (80022d4 <stm32_clock_init+0x104>)
 80022a2:	689b      	ldr	r3, [r3, #8]
 80022a4:	f043 0302 	orr.w	r3, r3, #2
 80022a8:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80022aa:	bf00      	nop
 80022ac:	4b09      	ldr	r3, [pc, #36]	; (80022d4 <stm32_clock_init+0x104>)
 80022ae:	689b      	ldr	r3, [r3, #8]
 80022b0:	f003 030c 	and.w	r3, r3, #12
 80022b4:	2b08      	cmp	r3, #8
 80022b6:	d1f9      	bne.n	80022ac <stm32_clock_init+0xdc>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80022b8:	4a06      	ldr	r2, [pc, #24]	; (80022d4 <stm32_clock_init+0x104>)
 80022ba:	4b06      	ldr	r3, [pc, #24]	; (80022d4 <stm32_clock_init+0x104>)
 80022bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80022be:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80022c2:	6453      	str	r3, [r2, #68]	; 0x44
 80022c4:	4a03      	ldr	r2, [pc, #12]	; (80022d4 <stm32_clock_init+0x104>)
 80022c6:	4b03      	ldr	r3, [pc, #12]	; (80022d4 <stm32_clock_init+0x104>)
 80022c8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80022ca:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80022ce:	6653      	str	r3, [r2, #100]	; 0x64
}
 80022d0:	4770      	bx	lr
 80022d2:	bf00      	nop
 80022d4:	40023800 	.word	0x40023800
 80022d8:	40007000 	.word	0x40007000
 80022dc:	07405408 	.word	0x07405408
 80022e0:	38089400 	.word	0x38089400
 80022e4:	40023c00 	.word	0x40023c00
 80022e8:	f3af 8000 	nop.w
 80022ec:	f3af 8000 	nop.w

080022f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80022f0:	b082      	sub	sp, #8
 80022f2:	2320      	movs	r3, #32
 80022f4:	9301      	str	r3, [sp, #4]
 80022f6:	9b01      	ldr	r3, [sp, #4]
 80022f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80022fc:	b002      	add	sp, #8
 80022fe:	4770      	bx	lr

08002300 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002300:	b082      	sub	sp, #8
 8002302:	2300      	movs	r3, #0
 8002304:	9301      	str	r3, [sp, #4]
 8002306:	9b01      	ldr	r3, [sp, #4]
 8002308:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800230c:	b002      	add	sp, #8
 800230e:	4770      	bx	lr

08002310 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002310:	b508      	push	{r3, lr}

  port_lock();
 8002312:	f7ff ffed 	bl	80022f0 <port_lock>
}
 8002316:	bd08      	pop	{r3, pc}
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002320:	b508      	push	{r3, lr}

  port_unlock();
 8002322:	f7ff ffed 	bl	8002300 <port_unlock>
}
 8002326:	bd08      	pop	{r3, pc}
 8002328:	f3af 8000 	nop.w
 800232c:	f3af 8000 	nop.w

08002330 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002330:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002332:	f7ff ffed 	bl	8002310 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002336:	bd08      	pop	{r3, pc}
 8002338:	f3af 8000 	nop.w
 800233c:	f3af 8000 	nop.w

08002340 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002340:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002342:	f7ff ffed 	bl	8002320 <port_unlock_from_isr>
}
 8002346:	bd08      	pop	{r3, pc}
 8002348:	f3af 8000 	nop.w
 800234c:	f3af 8000 	nop.w

08002350 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002350:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002352:	f7ff ffed 	bl	8002330 <chSysLockFromISR>
}
 8002356:	bd08      	pop	{r3, pc}
 8002358:	f3af 8000 	nop.w
 800235c:	f3af 8000 	nop.w

08002360 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002360:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002362:	f7ff ffed 	bl	8002340 <chSysUnlockFromISR>
}
 8002366:	bd08      	pop	{r3, pc}
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8002370:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8002372:	f7fe f915 	bl	80005a0 <chSysTimerHandlerI>
}
 8002376:	bd08      	pop	{r3, pc}
 8002378:	f3af 8000 	nop.w
 800237c:	f3af 8000 	nop.w

08002380 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8002380:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 8002382:	f7ff ffe5 	bl	8002350 <osalSysLockFromISR>
  osalOsTimerHandlerI();
 8002386:	f7ff fff3 	bl	8002370 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 800238a:	f7ff ffe9 	bl	8002360 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 800238e:	f7ff f9bf 	bl	8001710 <_port_irq_epilogue>
}
 8002392:	bd08      	pop	{r3, pc}
 8002394:	f3af 8000 	nop.w
 8002398:	f3af 8000 	nop.w
 800239c:	f3af 8000 	nop.w

080023a0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80023a0:	b508      	push	{r3, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 80023a2:	4b07      	ldr	r3, [pc, #28]	; (80023c0 <st_lld_init+0x20>)
 80023a4:	4a07      	ldr	r2, [pc, #28]	; (80023c4 <st_lld_init+0x24>)
 80023a6:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 80023a8:	4b05      	ldr	r3, [pc, #20]	; (80023c0 <st_lld_init+0x20>)
 80023aa:	2200      	movs	r2, #0
 80023ac:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80023ae:	4b04      	ldr	r3, [pc, #16]	; (80023c0 <st_lld_init+0x20>)
 80023b0:	2207      	movs	r2, #7
 80023b2:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 80023b4:	200b      	movs	r0, #11
 80023b6:	2108      	movs	r1, #8
 80023b8:	f7ff fc62 	bl	8001c80 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80023bc:	bd08      	pop	{r3, pc}
 80023be:	bf00      	nop
 80023c0:	e000e010 	.word	0xe000e010
 80023c4:	0002903f 	.word	0x0002903f
 80023c8:	f3af 8000 	nop.w
 80023cc:	f3af 8000 	nop.w

080023d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80023d0:	b082      	sub	sp, #8
 80023d2:	2320      	movs	r3, #32
 80023d4:	9301      	str	r3, [sp, #4]
 80023d6:	9b01      	ldr	r3, [sp, #4]
 80023d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80023dc:	b002      	add	sp, #8
 80023de:	4770      	bx	lr

080023e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80023e0:	b082      	sub	sp, #8
 80023e2:	2300      	movs	r3, #0
 80023e4:	9301      	str	r3, [sp, #4]
 80023e6:	9b01      	ldr	r3, [sp, #4]
 80023e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80023ec:	b002      	add	sp, #8
 80023ee:	4770      	bx	lr

080023f0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80023f0:	b508      	push	{r3, lr}

  port_lock();
 80023f2:	f7ff ffed 	bl	80023d0 <port_lock>
}
 80023f6:	bd08      	pop	{r3, pc}
 80023f8:	f3af 8000 	nop.w
 80023fc:	f3af 8000 	nop.w

08002400 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002400:	b508      	push	{r3, lr}

  port_unlock();
 8002402:	f7ff ffed 	bl	80023e0 <port_unlock>
}
 8002406:	bd08      	pop	{r3, pc}
 8002408:	f3af 8000 	nop.w
 800240c:	f3af 8000 	nop.w

08002410 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002410:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002412:	f7ff ffed 	bl	80023f0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002416:	bd08      	pop	{r3, pc}
 8002418:	f3af 8000 	nop.w
 800241c:	f3af 8000 	nop.w

08002420 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002420:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002422:	f7ff ffed 	bl	8002400 <port_unlock_from_isr>
}
 8002426:	bd08      	pop	{r3, pc}
 8002428:	f3af 8000 	nop.w
 800242c:	f3af 8000 	nop.w

08002430 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002430:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002432:	f7ff ffed 	bl	8002410 <chSysLockFromISR>
}
 8002436:	bd08      	pop	{r3, pc}
 8002438:	f3af 8000 	nop.w
 800243c:	f3af 8000 	nop.w

08002440 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002440:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002442:	f7ff ffed 	bl	8002420 <chSysUnlockFromISR>
}
 8002446:	bd08      	pop	{r3, pc}
 8002448:	f3af 8000 	nop.w
 800244c:	f3af 8000 	nop.w

08002450 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8002450:	b500      	push	{lr}
 8002452:	b083      	sub	sp, #12
 8002454:	9001      	str	r0, [sp, #4]
 8002456:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8002458:	9801      	ldr	r0, [sp, #4]
 800245a:	9900      	ldr	r1, [sp, #0]
 800245c:	f7fe fca0 	bl	8000da0 <chThdResumeI>
}
 8002460:	b003      	add	sp, #12
 8002462:	f85d fb04 	ldr.w	pc, [sp], #4
 8002466:	bf00      	nop
 8002468:	f3af 8000 	nop.w
 800246c:	f3af 8000 	nop.w

08002470 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 8002470:	b500      	push	{lr}
 8002472:	b083      	sub	sp, #12
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 8002474:	4b3b      	ldr	r3, [pc, #236]	; (8002564 <Vector88+0xf4>)
 8002476:	681b      	ldr	r3, [r3, #0]
 8002478:	9301      	str	r3, [sp, #4]
  ADC1->SR = 0;
 800247a:	4b3a      	ldr	r3, [pc, #232]	; (8002564 <Vector88+0xf4>)
 800247c:	2200      	movs	r2, #0
 800247e:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8002480:	9b01      	ldr	r3, [sp, #4]
 8002482:	f003 0320 	and.w	r3, r3, #32
 8002486:	2b00      	cmp	r3, #0
 8002488:	d02d      	beq.n	80024e6 <Vector88+0x76>
 800248a:	4b37      	ldr	r3, [pc, #220]	; (8002568 <Vector88+0xf8>)
 800248c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800248e:	681b      	ldr	r3, [r3, #0]
 8002490:	685b      	ldr	r3, [r3, #4]
 8002492:	2b00      	cmp	r3, #0
 8002494:	d027      	beq.n	80024e6 <Vector88+0x76>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 8002496:	4b34      	ldr	r3, [pc, #208]	; (8002568 <Vector88+0xf8>)
 8002498:	691b      	ldr	r3, [r3, #16]
 800249a:	2b00      	cmp	r3, #0
 800249c:	d023      	beq.n	80024e6 <Vector88+0x76>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800249e:	4832      	ldr	r0, [pc, #200]	; (8002568 <Vector88+0xf8>)
 80024a0:	f000 f89e 	bl	80025e0 <adc_lld_stop_conversion>
 80024a4:	4b30      	ldr	r3, [pc, #192]	; (8002568 <Vector88+0xf8>)
 80024a6:	691b      	ldr	r3, [r3, #16]
 80024a8:	689b      	ldr	r3, [r3, #8]
 80024aa:	2b00      	cmp	r3, #0
 80024ac:	d00f      	beq.n	80024ce <Vector88+0x5e>
 80024ae:	4b2e      	ldr	r3, [pc, #184]	; (8002568 <Vector88+0xf8>)
 80024b0:	2205      	movs	r2, #5
 80024b2:	701a      	strb	r2, [r3, #0]
 80024b4:	4b2c      	ldr	r3, [pc, #176]	; (8002568 <Vector88+0xf8>)
 80024b6:	691b      	ldr	r3, [r3, #16]
 80024b8:	689b      	ldr	r3, [r3, #8]
 80024ba:	482b      	ldr	r0, [pc, #172]	; (8002568 <Vector88+0xf8>)
 80024bc:	2101      	movs	r1, #1
 80024be:	4798      	blx	r3
 80024c0:	4b29      	ldr	r3, [pc, #164]	; (8002568 <Vector88+0xf8>)
 80024c2:	781b      	ldrb	r3, [r3, #0]
 80024c4:	2b05      	cmp	r3, #5
 80024c6:	d102      	bne.n	80024ce <Vector88+0x5e>
 80024c8:	4b27      	ldr	r3, [pc, #156]	; (8002568 <Vector88+0xf8>)
 80024ca:	2202      	movs	r2, #2
 80024cc:	701a      	strb	r2, [r3, #0]
 80024ce:	4b26      	ldr	r3, [pc, #152]	; (8002568 <Vector88+0xf8>)
 80024d0:	2200      	movs	r2, #0
 80024d2:	611a      	str	r2, [r3, #16]
 80024d4:	f7ff ffac 	bl	8002430 <osalSysLockFromISR>
 80024d8:	4824      	ldr	r0, [pc, #144]	; (800256c <Vector88+0xfc>)
 80024da:	f04f 31ff 	mov.w	r1, #4294967295
 80024de:	f7ff ffb7 	bl	8002450 <osalThreadResumeI>
 80024e2:	f7ff ffad 	bl	8002440 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  sr = ADC2->SR;
 80024e6:	4b22      	ldr	r3, [pc, #136]	; (8002570 <Vector88+0x100>)
 80024e8:	681b      	ldr	r3, [r3, #0]
 80024ea:	9301      	str	r3, [sp, #4]
  ADC2->SR = 0;
 80024ec:	4b20      	ldr	r3, [pc, #128]	; (8002570 <Vector88+0x100>)
 80024ee:	2200      	movs	r2, #0
 80024f0:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
 80024f2:	9b01      	ldr	r3, [sp, #4]
 80024f4:	f003 0320 	and.w	r3, r3, #32
 80024f8:	2b00      	cmp	r3, #0
 80024fa:	d02d      	beq.n	8002558 <Vector88+0xe8>
 80024fc:	4b1d      	ldr	r3, [pc, #116]	; (8002574 <Vector88+0x104>)
 80024fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002500:	681b      	ldr	r3, [r3, #0]
 8002502:	685b      	ldr	r3, [r3, #4]
 8002504:	2b00      	cmp	r3, #0
 8002506:	d027      	beq.n	8002558 <Vector88+0xe8>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD2.grpp != NULL)
 8002508:	4b1a      	ldr	r3, [pc, #104]	; (8002574 <Vector88+0x104>)
 800250a:	691b      	ldr	r3, [r3, #16]
 800250c:	2b00      	cmp	r3, #0
 800250e:	d023      	beq.n	8002558 <Vector88+0xe8>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
 8002510:	4818      	ldr	r0, [pc, #96]	; (8002574 <Vector88+0x104>)
 8002512:	f000 f865 	bl	80025e0 <adc_lld_stop_conversion>
 8002516:	4b17      	ldr	r3, [pc, #92]	; (8002574 <Vector88+0x104>)
 8002518:	691b      	ldr	r3, [r3, #16]
 800251a:	689b      	ldr	r3, [r3, #8]
 800251c:	2b00      	cmp	r3, #0
 800251e:	d00f      	beq.n	8002540 <Vector88+0xd0>
 8002520:	4b14      	ldr	r3, [pc, #80]	; (8002574 <Vector88+0x104>)
 8002522:	2205      	movs	r2, #5
 8002524:	701a      	strb	r2, [r3, #0]
 8002526:	4b13      	ldr	r3, [pc, #76]	; (8002574 <Vector88+0x104>)
 8002528:	691b      	ldr	r3, [r3, #16]
 800252a:	689b      	ldr	r3, [r3, #8]
 800252c:	4811      	ldr	r0, [pc, #68]	; (8002574 <Vector88+0x104>)
 800252e:	2101      	movs	r1, #1
 8002530:	4798      	blx	r3
 8002532:	4b10      	ldr	r3, [pc, #64]	; (8002574 <Vector88+0x104>)
 8002534:	781b      	ldrb	r3, [r3, #0]
 8002536:	2b05      	cmp	r3, #5
 8002538:	d102      	bne.n	8002540 <Vector88+0xd0>
 800253a:	4b0e      	ldr	r3, [pc, #56]	; (8002574 <Vector88+0x104>)
 800253c:	2202      	movs	r2, #2
 800253e:	701a      	strb	r2, [r3, #0]
 8002540:	4b0c      	ldr	r3, [pc, #48]	; (8002574 <Vector88+0x104>)
 8002542:	2200      	movs	r2, #0
 8002544:	611a      	str	r2, [r3, #16]
 8002546:	f7ff ff73 	bl	8002430 <osalSysLockFromISR>
 800254a:	480b      	ldr	r0, [pc, #44]	; (8002578 <Vector88+0x108>)
 800254c:	f04f 31ff 	mov.w	r1, #4294967295
 8002550:	f7ff ff7e 	bl	8002450 <osalThreadResumeI>
 8002554:	f7ff ff74 	bl	8002440 <osalSysUnlockFromISR>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 8002558:	f7ff f8da 	bl	8001710 <_port_irq_epilogue>
}
 800255c:	b003      	add	sp, #12
 800255e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002562:	bf00      	nop
 8002564:	40012000 	.word	0x40012000
 8002568:	20000a84 	.word	0x20000a84
 800256c:	20000a98 	.word	0x20000a98
 8002570:	40012100 	.word	0x40012100
 8002574:	20000ab8 	.word	0x20000ab8
 8002578:	20000acc 	.word	0x20000acc
 800257c:	f3af 8000 	nop.w

08002580 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8002580:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8002582:	480e      	ldr	r0, [pc, #56]	; (80025bc <adc_lld_init+0x3c>)
 8002584:	f7ff f944 	bl	8001810 <adcObjectInit>
  ADCD1.adc = ADC1;
 8002588:	4b0c      	ldr	r3, [pc, #48]	; (80025bc <adc_lld_init+0x3c>)
 800258a:	4a0d      	ldr	r2, [pc, #52]	; (80025c0 <adc_lld_init+0x40>)
 800258c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 800258e:	4b0b      	ldr	r3, [pc, #44]	; (80025bc <adc_lld_init+0x3c>)
 8002590:	4a0c      	ldr	r2, [pc, #48]	; (80025c4 <adc_lld_init+0x44>)
 8002592:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8002594:	4b09      	ldr	r3, [pc, #36]	; (80025bc <adc_lld_init+0x3c>)
 8002596:	4a0c      	ldr	r2, [pc, #48]	; (80025c8 <adc_lld_init+0x48>)
 8002598:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
 800259a:	480c      	ldr	r0, [pc, #48]	; (80025cc <adc_lld_init+0x4c>)
 800259c:	f7ff f938 	bl	8001810 <adcObjectInit>
  ADCD2.adc = ADC2;
 80025a0:	4b0a      	ldr	r3, [pc, #40]	; (80025cc <adc_lld_init+0x4c>)
 80025a2:	4a0b      	ldr	r2, [pc, #44]	; (80025d0 <adc_lld_init+0x50>)
 80025a4:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
 80025a6:	4b09      	ldr	r3, [pc, #36]	; (80025cc <adc_lld_init+0x4c>)
 80025a8:	4a0a      	ldr	r2, [pc, #40]	; (80025d4 <adc_lld_init+0x54>)
 80025aa:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
 80025ac:	4b07      	ldr	r3, [pc, #28]	; (80025cc <adc_lld_init+0x4c>)
 80025ae:	4a0a      	ldr	r2, [pc, #40]	; (80025d8 <adc_lld_init+0x58>)
 80025b0:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 80025b2:	2012      	movs	r0, #18
 80025b4:	2106      	movs	r1, #6
 80025b6:	f7ff fb33 	bl	8001c20 <nvicEnableVector>
}
 80025ba:	bd08      	pop	{r3, pc}
 80025bc:	20000a84 	.word	0x20000a84
 80025c0:	40012000 	.word	0x40012000
 80025c4:	08003090 	.word	0x08003090
 80025c8:	00022c16 	.word	0x00022c16
 80025cc:	20000ab8 	.word	0x20000ab8
 80025d0:	40012100 	.word	0x40012100
 80025d4:	08003078 	.word	0x08003078
 80025d8:	02022c16 	.word	0x02022c16
 80025dc:	f3af 8000 	nop.w

080025e0 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 80025e0:	b082      	sub	sp, #8
 80025e2:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
 80025e4:	9b01      	ldr	r3, [sp, #4]
 80025e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	9a01      	ldr	r2, [sp, #4]
 80025ec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80025ee:	6812      	ldr	r2, [r2, #0]
 80025f0:	6812      	ldr	r2, [r2, #0]
 80025f2:	f022 021f 	bic.w	r2, r2, #31
 80025f6:	601a      	str	r2, [r3, #0]
 80025f8:	bf00      	nop
 80025fa:	9b01      	ldr	r3, [sp, #4]
 80025fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	681b      	ldr	r3, [r3, #0]
 8002602:	f003 0301 	and.w	r3, r3, #1
 8002606:	2b00      	cmp	r3, #0
 8002608:	d1f7      	bne.n	80025fa <adc_lld_stop_conversion+0x1a>
 800260a:	9b01      	ldr	r3, [sp, #4]
 800260c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800260e:	685b      	ldr	r3, [r3, #4]
 8002610:	9a01      	ldr	r2, [sp, #4]
 8002612:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8002614:	7a12      	ldrb	r2, [r2, #8]
 8002616:	4611      	mov	r1, r2
 8002618:	223d      	movs	r2, #61	; 0x3d
 800261a:	408a      	lsls	r2, r1
 800261c:	601a      	str	r2, [r3, #0]
  adcp->adc->CR1 = 0;
 800261e:	9b01      	ldr	r3, [sp, #4]
 8002620:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002622:	2200      	movs	r2, #0
 8002624:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
 8002626:	9b01      	ldr	r3, [sp, #4]
 8002628:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800262a:	2200      	movs	r2, #0
 800262c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800262e:	9b01      	ldr	r3, [sp, #4]
 8002630:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002632:	2201      	movs	r2, #1
 8002634:	609a      	str	r2, [r3, #8]
}
 8002636:	b002      	add	sp, #8
 8002638:	4770      	bx	lr
 800263a:	bf00      	nop
 800263c:	f3af 8000 	nop.w

08002640 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8002640:	b082      	sub	sp, #8
 8002642:	9001      	str	r0, [sp, #4]
 8002644:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8002646:	9b00      	ldr	r3, [sp, #0]
 8002648:	685a      	ldr	r2, [r3, #4]
 800264a:	9b01      	ldr	r3, [sp, #4]
 800264c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800264e:	9b00      	ldr	r3, [sp, #0]
 8002650:	689a      	ldr	r2, [r3, #8]
 8002652:	9b01      	ldr	r3, [sp, #4]
 8002654:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8002656:	9b00      	ldr	r3, [sp, #0]
 8002658:	68da      	ldr	r2, [r3, #12]
 800265a:	9b01      	ldr	r3, [sp, #4]
 800265c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800265e:	9b00      	ldr	r3, [sp, #0]
 8002660:	691a      	ldr	r2, [r3, #16]
 8002662:	9b01      	ldr	r3, [sp, #4]
 8002664:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8002666:	9b00      	ldr	r3, [sp, #0]
 8002668:	695a      	ldr	r2, [r3, #20]
 800266a:	9b01      	ldr	r3, [sp, #4]
 800266c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800266e:	9b00      	ldr	r3, [sp, #0]
 8002670:	699a      	ldr	r2, [r3, #24]
 8002672:	9b01      	ldr	r3, [sp, #4]
 8002674:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002676:	9b00      	ldr	r3, [sp, #0]
 8002678:	681a      	ldr	r2, [r3, #0]
 800267a:	9b01      	ldr	r3, [sp, #4]
 800267c:	601a      	str	r2, [r3, #0]
}
 800267e:	b002      	add	sp, #8
 8002680:	4770      	bx	lr
 8002682:	bf00      	nop
 8002684:	f3af 8000 	nop.w
 8002688:	f3af 8000 	nop.w
 800268c:	f3af 8000 	nop.w

08002690 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8002690:	b500      	push	{lr}
 8002692:	b083      	sub	sp, #12
 8002694:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8002696:	4a24      	ldr	r2, [pc, #144]	; (8002728 <_pal_lld_init+0x98>)
 8002698:	4b23      	ldr	r3, [pc, #140]	; (8002728 <_pal_lld_init+0x98>)
 800269a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800269c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 80026a0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 80026a4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80026a6:	4a20      	ldr	r2, [pc, #128]	; (8002728 <_pal_lld_init+0x98>)
 80026a8:	4b1f      	ldr	r3, [pc, #124]	; (8002728 <_pal_lld_init+0x98>)
 80026aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80026ac:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 80026b0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 80026b4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80026b6:	9b01      	ldr	r3, [sp, #4]
 80026b8:	481c      	ldr	r0, [pc, #112]	; (800272c <_pal_lld_init+0x9c>)
 80026ba:	4619      	mov	r1, r3
 80026bc:	f7ff ffc0 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80026c0:	9b01      	ldr	r3, [sp, #4]
 80026c2:	331c      	adds	r3, #28
 80026c4:	481a      	ldr	r0, [pc, #104]	; (8002730 <_pal_lld_init+0xa0>)
 80026c6:	4619      	mov	r1, r3
 80026c8:	f7ff ffba 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80026cc:	9b01      	ldr	r3, [sp, #4]
 80026ce:	3338      	adds	r3, #56	; 0x38
 80026d0:	4818      	ldr	r0, [pc, #96]	; (8002734 <_pal_lld_init+0xa4>)
 80026d2:	4619      	mov	r1, r3
 80026d4:	f7ff ffb4 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 80026d8:	9b01      	ldr	r3, [sp, #4]
 80026da:	3354      	adds	r3, #84	; 0x54
 80026dc:	4816      	ldr	r0, [pc, #88]	; (8002738 <_pal_lld_init+0xa8>)
 80026de:	4619      	mov	r1, r3
 80026e0:	f7ff ffae 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 80026e4:	9b01      	ldr	r3, [sp, #4]
 80026e6:	3370      	adds	r3, #112	; 0x70
 80026e8:	4814      	ldr	r0, [pc, #80]	; (800273c <_pal_lld_init+0xac>)
 80026ea:	4619      	mov	r1, r3
 80026ec:	f7ff ffa8 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80026f0:	9b01      	ldr	r3, [sp, #4]
 80026f2:	338c      	adds	r3, #140	; 0x8c
 80026f4:	4812      	ldr	r0, [pc, #72]	; (8002740 <_pal_lld_init+0xb0>)
 80026f6:	4619      	mov	r1, r3
 80026f8:	f7ff ffa2 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 80026fc:	9b01      	ldr	r3, [sp, #4]
 80026fe:	33a8      	adds	r3, #168	; 0xa8
 8002700:	4810      	ldr	r0, [pc, #64]	; (8002744 <_pal_lld_init+0xb4>)
 8002702:	4619      	mov	r1, r3
 8002704:	f7ff ff9c 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8002708:	9b01      	ldr	r3, [sp, #4]
 800270a:	33c4      	adds	r3, #196	; 0xc4
 800270c:	480e      	ldr	r0, [pc, #56]	; (8002748 <_pal_lld_init+0xb8>)
 800270e:	4619      	mov	r1, r3
 8002710:	f7ff ff96 	bl	8002640 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 8002714:	9b01      	ldr	r3, [sp, #4]
 8002716:	33e0      	adds	r3, #224	; 0xe0
 8002718:	480c      	ldr	r0, [pc, #48]	; (800274c <_pal_lld_init+0xbc>)
 800271a:	4619      	mov	r1, r3
 800271c:	f7ff ff90 	bl	8002640 <initgpio>
#endif
}
 8002720:	b003      	add	sp, #12
 8002722:	f85d fb04 	ldr.w	pc, [sp], #4
 8002726:	bf00      	nop
 8002728:	40023800 	.word	0x40023800
 800272c:	40020000 	.word	0x40020000
 8002730:	40020400 	.word	0x40020400
 8002734:	40020800 	.word	0x40020800
 8002738:	40020c00 	.word	0x40020c00
 800273c:	40021000 	.word	0x40021000
 8002740:	40021400 	.word	0x40021400
 8002744:	40021800 	.word	0x40021800
 8002748:	40021c00 	.word	0x40021c00
 800274c:	40022000 	.word	0x40022000

08002750 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8002750:	b08e      	sub	sp, #56	; 0x38
 8002752:	9003      	str	r0, [sp, #12]
 8002754:	9102      	str	r1, [sp, #8]
 8002756:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8002758:	9b01      	ldr	r3, [sp, #4]
 800275a:	f003 0303 	and.w	r3, r3, #3
 800275e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8002760:	9b01      	ldr	r3, [sp, #4]
 8002762:	f003 0304 	and.w	r3, r3, #4
 8002766:	089b      	lsrs	r3, r3, #2
 8002768:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800276a:	9b01      	ldr	r3, [sp, #4]
 800276c:	f003 0318 	and.w	r3, r3, #24
 8002770:	08db      	lsrs	r3, r3, #3
 8002772:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8002774:	9b01      	ldr	r3, [sp, #4]
 8002776:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800277a:	095b      	lsrs	r3, r3, #5
 800277c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800277e:	9b01      	ldr	r3, [sp, #4]
 8002780:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8002784:	09db      	lsrs	r3, r3, #7
 8002786:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8002788:	2300      	movs	r3, #0
 800278a:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
 800278c:	9b02      	ldr	r3, [sp, #8]
 800278e:	f003 0301 	and.w	r3, r3, #1
 8002792:	2b00      	cmp	r3, #0
 8002794:	d054      	beq.n	8002840 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8002796:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002798:	f003 0307 	and.w	r3, r3, #7
 800279c:	009b      	lsls	r3, r3, #2
 800279e:	461a      	mov	r2, r3
 80027a0:	9b08      	ldr	r3, [sp, #32]
 80027a2:	4093      	lsls	r3, r2
 80027a4:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 80027a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80027a8:	f003 0307 	and.w	r3, r3, #7
 80027ac:	009b      	lsls	r3, r3, #2
 80027ae:	461a      	mov	r2, r3
 80027b0:	230f      	movs	r3, #15
 80027b2:	4093      	lsls	r3, r2
 80027b4:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 80027b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80027b8:	2b07      	cmp	r3, #7
 80027ba:	d809      	bhi.n	80027d0 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 80027bc:	9b03      	ldr	r3, [sp, #12]
 80027be:	6a1a      	ldr	r2, [r3, #32]
 80027c0:	9b06      	ldr	r3, [sp, #24]
 80027c2:	43db      	mvns	r3, r3
 80027c4:	401a      	ands	r2, r3
 80027c6:	9b07      	ldr	r3, [sp, #28]
 80027c8:	431a      	orrs	r2, r3
 80027ca:	9b03      	ldr	r3, [sp, #12]
 80027cc:	621a      	str	r2, [r3, #32]
 80027ce:	e008      	b.n	80027e2 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 80027d0:	9b03      	ldr	r3, [sp, #12]
 80027d2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80027d4:	9b06      	ldr	r3, [sp, #24]
 80027d6:	43db      	mvns	r3, r3
 80027d8:	401a      	ands	r2, r3
 80027da:	9b07      	ldr	r3, [sp, #28]
 80027dc:	431a      	orrs	r2, r3
 80027de:	9b03      	ldr	r3, [sp, #12]
 80027e0:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 80027e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80027e4:	2201      	movs	r2, #1
 80027e6:	fa02 f303 	lsl.w	r3, r2, r3
 80027ea:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80027ec:	9b03      	ldr	r3, [sp, #12]
 80027ee:	685a      	ldr	r2, [r3, #4]
 80027f0:	9b05      	ldr	r3, [sp, #20]
 80027f2:	43db      	mvns	r3, r3
 80027f4:	401a      	ands	r2, r3
 80027f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80027f8:	431a      	orrs	r2, r3
 80027fa:	9b03      	ldr	r3, [sp, #12]
 80027fc:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 80027fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002800:	005b      	lsls	r3, r3, #1
 8002802:	461a      	mov	r2, r3
 8002804:	2303      	movs	r3, #3
 8002806:	4093      	lsls	r3, r2
 8002808:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800280a:	9b03      	ldr	r3, [sp, #12]
 800280c:	689a      	ldr	r2, [r3, #8]
 800280e:	9b04      	ldr	r3, [sp, #16]
 8002810:	43db      	mvns	r3, r3
 8002812:	401a      	ands	r2, r3
 8002814:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002816:	431a      	orrs	r2, r3
 8002818:	9b03      	ldr	r3, [sp, #12]
 800281a:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800281c:	9b03      	ldr	r3, [sp, #12]
 800281e:	68da      	ldr	r2, [r3, #12]
 8002820:	9b04      	ldr	r3, [sp, #16]
 8002822:	43db      	mvns	r3, r3
 8002824:	401a      	ands	r2, r3
 8002826:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002828:	431a      	orrs	r2, r3
 800282a:	9b03      	ldr	r3, [sp, #12]
 800282c:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 800282e:	9b03      	ldr	r3, [sp, #12]
 8002830:	681a      	ldr	r2, [r3, #0]
 8002832:	9b04      	ldr	r3, [sp, #16]
 8002834:	43db      	mvns	r3, r3
 8002836:	401a      	ands	r2, r3
 8002838:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800283a:	431a      	orrs	r2, r3
 800283c:	9b03      	ldr	r3, [sp, #12]
 800283e:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 8002840:	9b02      	ldr	r3, [sp, #8]
 8002842:	085b      	lsrs	r3, r3, #1
 8002844:	9302      	str	r3, [sp, #8]
    if (!mask)
 8002846:	9b02      	ldr	r3, [sp, #8]
 8002848:	2b00      	cmp	r3, #0
 800284a:	d100      	bne.n	800284e <_pal_lld_setgroupmode+0xfe>
      return;
 800284c:	e00f      	b.n	800286e <_pal_lld_setgroupmode+0x11e>
    otyper <<= 1;
 800284e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002850:	005b      	lsls	r3, r3, #1
 8002852:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8002854:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002856:	009b      	lsls	r3, r3, #2
 8002858:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 800285a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800285c:	009b      	lsls	r3, r3, #2
 800285e:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8002860:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002862:	009b      	lsls	r3, r3, #2
 8002864:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 8002866:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002868:	3301      	adds	r3, #1
 800286a:	9309      	str	r3, [sp, #36]	; 0x24
  }
 800286c:	e78e      	b.n	800278c <_pal_lld_setgroupmode+0x3c>
}
 800286e:	b00e      	add	sp, #56	; 0x38
 8002870:	4770      	bx	lr
 8002872:	bf00      	nop
 8002874:	f3af 8000 	nop.w
 8002878:	f3af 8000 	nop.w
 800287c:	f3af 8000 	nop.w

08002880 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8002880:	b508      	push	{r3, lr}

  dummytx = 0xFFFF;
 8002882:	4b0b      	ldr	r3, [pc, #44]	; (80028b0 <spi_lld_init+0x30>)
 8002884:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002888:	801a      	strh	r2, [r3, #0]
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800288a:	480a      	ldr	r0, [pc, #40]	; (80028b4 <spi_lld_init+0x34>)
 800288c:	f7ff f9b0 	bl	8001bf0 <spiObjectInit>
  SPID2.spi       = SPI2;
 8002890:	4b08      	ldr	r3, [pc, #32]	; (80028b4 <spi_lld_init+0x34>)
 8002892:	4a09      	ldr	r2, [pc, #36]	; (80028b8 <spi_lld_init+0x38>)
 8002894:	61da      	str	r2, [r3, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8002896:	4b07      	ldr	r3, [pc, #28]	; (80028b4 <spi_lld_init+0x34>)
 8002898:	4a08      	ldr	r2, [pc, #32]	; (80028bc <spi_lld_init+0x3c>)
 800289a:	621a      	str	r2, [r3, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800289c:	4b05      	ldr	r3, [pc, #20]	; (80028b4 <spi_lld_init+0x34>)
 800289e:	4a08      	ldr	r2, [pc, #32]	; (80028c0 <spi_lld_init+0x40>)
 80028a0:	625a      	str	r2, [r3, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 80028a2:	4b04      	ldr	r3, [pc, #16]	; (80028b4 <spi_lld_init+0x34>)
 80028a4:	4a07      	ldr	r2, [pc, #28]	; (80028c4 <spi_lld_init+0x44>)
 80028a6:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 80028a8:	4b02      	ldr	r3, [pc, #8]	; (80028b4 <spi_lld_init+0x34>)
 80028aa:	4a07      	ldr	r2, [pc, #28]	; (80028c8 <spi_lld_init+0x48>)
 80028ac:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 80028ae:	bd08      	pop	{r3, pc}
 80028b0:	20000b1c 	.word	0x20000b1c
 80028b4:	20000aec 	.word	0x20000aec
 80028b8:	40003800 	.word	0x40003800
 80028bc:	08003024 	.word	0x08003024
 80028c0:	08003030 	.word	0x08003030
 80028c4:	00010016 	.word	0x00010016
 80028c8:	00010046 	.word	0x00010046
 80028cc:	f3af 8000 	nop.w

080028d0 <icu_lld_serve_interrupt>:
/**
 * @brief   Shared IRQ handler.
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 */
static void icu_lld_serve_interrupt(ICUDriver *icup) {
 80028d0:	b500      	push	{lr}
 80028d2:	b085      	sub	sp, #20
 80028d4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = icup->tim->SR;
 80028d6:	9b01      	ldr	r3, [sp, #4]
 80028d8:	68db      	ldr	r3, [r3, #12]
 80028da:	691b      	ldr	r3, [r3, #16]
 80028dc:	9303      	str	r3, [sp, #12]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80028de:	9b01      	ldr	r3, [sp, #4]
 80028e0:	68db      	ldr	r3, [r3, #12]
 80028e2:	68db      	ldr	r3, [r3, #12]
 80028e4:	b2db      	uxtb	r3, r3
 80028e6:	9a03      	ldr	r2, [sp, #12]
 80028e8:	4013      	ands	r3, r2
 80028ea:	9303      	str	r3, [sp, #12]
  icup->tim->SR = ~sr;
 80028ec:	9b01      	ldr	r3, [sp, #4]
 80028ee:	68db      	ldr	r3, [r3, #12]
 80028f0:	9a03      	ldr	r2, [sp, #12]
 80028f2:	43d2      	mvns	r2, r2
 80028f4:	611a      	str	r2, [r3, #16]
  if (icup->config->channel == ICU_CHANNEL_1) {
 80028f6:	9b01      	ldr	r3, [sp, #4]
 80028f8:	685b      	ldr	r3, [r3, #4]
 80028fa:	7d1b      	ldrb	r3, [r3, #20]
 80028fc:	2b00      	cmp	r3, #0
 80028fe:	d129      	bne.n	8002954 <icu_lld_serve_interrupt+0x84>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8002900:	9b03      	ldr	r3, [sp, #12]
 8002902:	f003 0304 	and.w	r3, r3, #4
 8002906:	2b00      	cmp	r3, #0
 8002908:	d00d      	beq.n	8002926 <icu_lld_serve_interrupt+0x56>
      _icu_isr_invoke_width_cb(icup);
 800290a:	9b01      	ldr	r3, [sp, #4]
 800290c:	781b      	ldrb	r3, [r3, #0]
 800290e:	2b04      	cmp	r3, #4
 8002910:	d109      	bne.n	8002926 <icu_lld_serve_interrupt+0x56>
 8002912:	9b01      	ldr	r3, [sp, #4]
 8002914:	685b      	ldr	r3, [r3, #4]
 8002916:	689b      	ldr	r3, [r3, #8]
 8002918:	2b00      	cmp	r3, #0
 800291a:	d004      	beq.n	8002926 <icu_lld_serve_interrupt+0x56>
 800291c:	9b01      	ldr	r3, [sp, #4]
 800291e:	685b      	ldr	r3, [r3, #4]
 8002920:	689b      	ldr	r3, [r3, #8]
 8002922:	9801      	ldr	r0, [sp, #4]
 8002924:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 8002926:	9b03      	ldr	r3, [sp, #12]
 8002928:	f003 0302 	and.w	r3, r3, #2
 800292c:	2b00      	cmp	r3, #0
 800292e:	d03a      	beq.n	80029a6 <icu_lld_serve_interrupt+0xd6>
      _icu_isr_invoke_period_cb(icup);
 8002930:	9b01      	ldr	r3, [sp, #4]
 8002932:	781b      	ldrb	r3, [r3, #0]
 8002934:	2b04      	cmp	r3, #4
 8002936:	d109      	bne.n	800294c <icu_lld_serve_interrupt+0x7c>
 8002938:	9b01      	ldr	r3, [sp, #4]
 800293a:	685b      	ldr	r3, [r3, #4]
 800293c:	68db      	ldr	r3, [r3, #12]
 800293e:	2b00      	cmp	r3, #0
 8002940:	d004      	beq.n	800294c <icu_lld_serve_interrupt+0x7c>
 8002942:	9b01      	ldr	r3, [sp, #4]
 8002944:	685b      	ldr	r3, [r3, #4]
 8002946:	68db      	ldr	r3, [r3, #12]
 8002948:	9801      	ldr	r0, [sp, #4]
 800294a:	4798      	blx	r3
 800294c:	9b01      	ldr	r3, [sp, #4]
 800294e:	2204      	movs	r2, #4
 8002950:	701a      	strb	r2, [r3, #0]
 8002952:	e028      	b.n	80029a6 <icu_lld_serve_interrupt+0xd6>
  }
  else {
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 8002954:	9b03      	ldr	r3, [sp, #12]
 8002956:	f003 0302 	and.w	r3, r3, #2
 800295a:	2b00      	cmp	r3, #0
 800295c:	d00d      	beq.n	800297a <icu_lld_serve_interrupt+0xaa>
      _icu_isr_invoke_width_cb(icup);
 800295e:	9b01      	ldr	r3, [sp, #4]
 8002960:	781b      	ldrb	r3, [r3, #0]
 8002962:	2b04      	cmp	r3, #4
 8002964:	d109      	bne.n	800297a <icu_lld_serve_interrupt+0xaa>
 8002966:	9b01      	ldr	r3, [sp, #4]
 8002968:	685b      	ldr	r3, [r3, #4]
 800296a:	689b      	ldr	r3, [r3, #8]
 800296c:	2b00      	cmp	r3, #0
 800296e:	d004      	beq.n	800297a <icu_lld_serve_interrupt+0xaa>
 8002970:	9b01      	ldr	r3, [sp, #4]
 8002972:	685b      	ldr	r3, [r3, #4]
 8002974:	689b      	ldr	r3, [r3, #8]
 8002976:	9801      	ldr	r0, [sp, #4]
 8002978:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 800297a:	9b03      	ldr	r3, [sp, #12]
 800297c:	f003 0304 	and.w	r3, r3, #4
 8002980:	2b00      	cmp	r3, #0
 8002982:	d010      	beq.n	80029a6 <icu_lld_serve_interrupt+0xd6>
      _icu_isr_invoke_period_cb(icup);
 8002984:	9b01      	ldr	r3, [sp, #4]
 8002986:	781b      	ldrb	r3, [r3, #0]
 8002988:	2b04      	cmp	r3, #4
 800298a:	d109      	bne.n	80029a0 <icu_lld_serve_interrupt+0xd0>
 800298c:	9b01      	ldr	r3, [sp, #4]
 800298e:	685b      	ldr	r3, [r3, #4]
 8002990:	68db      	ldr	r3, [r3, #12]
 8002992:	2b00      	cmp	r3, #0
 8002994:	d004      	beq.n	80029a0 <icu_lld_serve_interrupt+0xd0>
 8002996:	9b01      	ldr	r3, [sp, #4]
 8002998:	685b      	ldr	r3, [r3, #4]
 800299a:	68db      	ldr	r3, [r3, #12]
 800299c:	9801      	ldr	r0, [sp, #4]
 800299e:	4798      	blx	r3
 80029a0:	9b01      	ldr	r3, [sp, #4]
 80029a2:	2204      	movs	r2, #4
 80029a4:	701a      	strb	r2, [r3, #0]
  }
  if ((sr & STM32_TIM_SR_UIF) != 0)
 80029a6:	9b03      	ldr	r3, [sp, #12]
 80029a8:	f003 0301 	and.w	r3, r3, #1
 80029ac:	2b00      	cmp	r3, #0
 80029ae:	d007      	beq.n	80029c0 <icu_lld_serve_interrupt+0xf0>
    _icu_isr_invoke_overflow_cb(icup);
 80029b0:	9b01      	ldr	r3, [sp, #4]
 80029b2:	685b      	ldr	r3, [r3, #4]
 80029b4:	691b      	ldr	r3, [r3, #16]
 80029b6:	9801      	ldr	r0, [sp, #4]
 80029b8:	4798      	blx	r3
 80029ba:	9b01      	ldr	r3, [sp, #4]
 80029bc:	2203      	movs	r2, #3
 80029be:	701a      	strb	r2, [r3, #0]
}
 80029c0:	b005      	add	sp, #20
 80029c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80029c6:	bf00      	nop
 80029c8:	f3af 8000 	nop.w
 80029cc:	f3af 8000 	nop.w

080029d0 <VectorB0>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 80029d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  icu_lld_serve_interrupt(&ICUD2);
 80029d2:	4803      	ldr	r0, [pc, #12]	; (80029e0 <VectorB0+0x10>)
 80029d4:	f7ff ff7c 	bl	80028d0 <icu_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80029d8:	f7fe fe9a 	bl	8001710 <_port_irq_epilogue>
}
 80029dc:	bd08      	pop	{r3, pc}
 80029de:	bf00      	nop
 80029e0:	20000b20 	.word	0x20000b20
 80029e4:	f3af 8000 	nop.w
 80029e8:	f3af 8000 	nop.w
 80029ec:	f3af 8000 	nop.w

080029f0 <Vector108>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM5_HANDLER) {
 80029f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  icu_lld_serve_interrupt(&ICUD5);
 80029f2:	4803      	ldr	r0, [pc, #12]	; (8002a00 <Vector108+0x10>)
 80029f4:	f7ff ff6c 	bl	80028d0 <icu_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80029f8:	f7fe fe8a 	bl	8001710 <_port_irq_epilogue>
}
 80029fc:	bd08      	pop	{r3, pc}
 80029fe:	bf00      	nop
 8002a00:	20000b38 	.word	0x20000b38
 8002a04:	f3af 8000 	nop.w
 8002a08:	f3af 8000 	nop.w
 8002a0c:	f3af 8000 	nop.w

08002a10 <icu_lld_init>:
/**
 * @brief   Low level ICU driver initialization.
 *
 * @notapi
 */
void icu_lld_init(void) {
 8002a10:	b508      	push	{r3, lr}
  ICUD1.tim = STM32_TIM1;
#endif

#if STM32_ICU_USE_TIM2
  /* Driver initialization.*/
  icuObjectInit(&ICUD2);
 8002a12:	4807      	ldr	r0, [pc, #28]	; (8002a30 <icu_lld_init+0x20>)
 8002a14:	f7fe ff24 	bl	8001860 <icuObjectInit>
  ICUD2.tim = STM32_TIM2;
 8002a18:	4b05      	ldr	r3, [pc, #20]	; (8002a30 <icu_lld_init+0x20>)
 8002a1a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002a1e:	60da      	str	r2, [r3, #12]
  ICUD4.tim = STM32_TIM4;
#endif

#if STM32_ICU_USE_TIM5
  /* Driver initialization.*/
  icuObjectInit(&ICUD5);
 8002a20:	4804      	ldr	r0, [pc, #16]	; (8002a34 <icu_lld_init+0x24>)
 8002a22:	f7fe ff1d 	bl	8001860 <icuObjectInit>
  ICUD5.tim = STM32_TIM5;
 8002a26:	4b03      	ldr	r3, [pc, #12]	; (8002a34 <icu_lld_init+0x24>)
 8002a28:	4a03      	ldr	r2, [pc, #12]	; (8002a38 <icu_lld_init+0x28>)
 8002a2a:	60da      	str	r2, [r3, #12]
#if STM32_ICU_USE_TIM9
  /* Driver initialization.*/
  icuObjectInit(&ICUD9);
  ICUD9.tim = STM32_TIM9;
#endif
}
 8002a2c:	bd08      	pop	{r3, pc}
 8002a2e:	bf00      	nop
 8002a30:	20000b20 	.word	0x20000b20
 8002a34:	20000b38 	.word	0x20000b38
 8002a38:	40000c00 	.word	0x40000c00
 8002a3c:	f3af 8000 	nop.w

08002a40 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002a40:	b082      	sub	sp, #8
 8002a42:	2320      	movs	r3, #32
 8002a44:	9301      	str	r3, [sp, #4]
 8002a46:	9b01      	ldr	r3, [sp, #4]
 8002a48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002a4c:	b002      	add	sp, #8
 8002a4e:	4770      	bx	lr

08002a50 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002a50:	b082      	sub	sp, #8
 8002a52:	2300      	movs	r3, #0
 8002a54:	9301      	str	r3, [sp, #4]
 8002a56:	9b01      	ldr	r3, [sp, #4]
 8002a58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002a5c:	b002      	add	sp, #8
 8002a5e:	4770      	bx	lr

08002a60 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002a60:	b508      	push	{r3, lr}

  port_lock();
 8002a62:	f7ff ffed 	bl	8002a40 <port_lock>
}
 8002a66:	bd08      	pop	{r3, pc}
 8002a68:	f3af 8000 	nop.w
 8002a6c:	f3af 8000 	nop.w

08002a70 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002a70:	b508      	push	{r3, lr}

  port_unlock();
 8002a72:	f7ff ffed 	bl	8002a50 <port_unlock>
}
 8002a76:	bd08      	pop	{r3, pc}
 8002a78:	f3af 8000 	nop.w
 8002a7c:	f3af 8000 	nop.w

08002a80 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002a80:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002a82:	f7ff ffed 	bl	8002a60 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002a86:	bd08      	pop	{r3, pc}
 8002a88:	f3af 8000 	nop.w
 8002a8c:	f3af 8000 	nop.w

08002a90 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002a90:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002a92:	f7ff ffed 	bl	8002a70 <port_unlock_from_isr>
}
 8002a96:	bd08      	pop	{r3, pc}
 8002a98:	f3af 8000 	nop.w
 8002a9c:	f3af 8000 	nop.w

08002aa0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8002aa0:	b082      	sub	sp, #8
 8002aa2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002aa4:	9b01      	ldr	r3, [sp, #4]
 8002aa6:	695a      	ldr	r2, [r3, #20]
 8002aa8:	9b01      	ldr	r3, [sp, #4]
 8002aaa:	699b      	ldr	r3, [r3, #24]
 8002aac:	429a      	cmp	r2, r3
 8002aae:	d105      	bne.n	8002abc <chOQIsEmptyI+0x1c>
 8002ab0:	9b01      	ldr	r3, [sp, #4]
 8002ab2:	689b      	ldr	r3, [r3, #8]
 8002ab4:	2b00      	cmp	r3, #0
 8002ab6:	d001      	beq.n	8002abc <chOQIsEmptyI+0x1c>
 8002ab8:	2301      	movs	r3, #1
 8002aba:	e000      	b.n	8002abe <chOQIsEmptyI+0x1e>
 8002abc:	2300      	movs	r3, #0
 8002abe:	f003 0301 	and.w	r3, r3, #1
 8002ac2:	b2db      	uxtb	r3, r3
}
 8002ac4:	4618      	mov	r0, r3
 8002ac6:	b002      	add	sp, #8
 8002ac8:	4770      	bx	lr
 8002aca:	bf00      	nop
 8002acc:	f3af 8000 	nop.w

08002ad0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002ad0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002ad2:	f7ff ffd5 	bl	8002a80 <chSysLockFromISR>
}
 8002ad6:	bd08      	pop	{r3, pc}
 8002ad8:	f3af 8000 	nop.w
 8002adc:	f3af 8000 	nop.w

08002ae0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002ae0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002ae2:	f7ff ffd5 	bl	8002a90 <chSysUnlockFromISR>
}
 8002ae6:	bd08      	pop	{r3, pc}
 8002ae8:	f3af 8000 	nop.w
 8002aec:	f3af 8000 	nop.w

08002af0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8002af0:	b500      	push	{lr}
 8002af2:	b083      	sub	sp, #12
 8002af4:	9001      	str	r0, [sp, #4]
 8002af6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8002af8:	9801      	ldr	r0, [sp, #4]
 8002afa:	9900      	ldr	r1, [sp, #0]
 8002afc:	f7fe fa60 	bl	8000fc0 <chEvtBroadcastFlagsI>
}
 8002b00:	b003      	add	sp, #12
 8002b02:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b06:	bf00      	nop
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8002b10:	b084      	sub	sp, #16
 8002b12:	9001      	str	r0, [sp, #4]
 8002b14:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8002b16:	9b01      	ldr	r3, [sp, #4]
 8002b18:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002b1a:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8002b1c:	9b01      	ldr	r3, [sp, #4]
 8002b1e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002b20:	4a1c      	ldr	r2, [pc, #112]	; (8002b94 <usart_init+0x84>)
 8002b22:	4293      	cmp	r3, r2
 8002b24:	d004      	beq.n	8002b30 <usart_init+0x20>
 8002b26:	9b01      	ldr	r3, [sp, #4]
 8002b28:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002b2a:	4a1b      	ldr	r2, [pc, #108]	; (8002b98 <usart_init+0x88>)
 8002b2c:	4293      	cmp	r3, r2
 8002b2e:	d107      	bne.n	8002b40 <usart_init+0x30>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8002b30:	9b00      	ldr	r3, [sp, #0]
 8002b32:	681b      	ldr	r3, [r3, #0]
 8002b34:	4a19      	ldr	r2, [pc, #100]	; (8002b9c <usart_init+0x8c>)
 8002b36:	fbb2 f2f3 	udiv	r2, r2, r3
 8002b3a:	9b03      	ldr	r3, [sp, #12]
 8002b3c:	609a      	str	r2, [r3, #8]
 8002b3e:	e006      	b.n	8002b4e <usart_init+0x3e>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8002b40:	9b00      	ldr	r3, [sp, #0]
 8002b42:	681b      	ldr	r3, [r3, #0]
 8002b44:	4a16      	ldr	r2, [pc, #88]	; (8002ba0 <usart_init+0x90>)
 8002b46:	fbb2 f2f3 	udiv	r2, r2, r3
 8002b4a:	9b03      	ldr	r3, [sp, #12]
 8002b4c:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002b4e:	9b00      	ldr	r3, [sp, #0]
 8002b50:	88db      	ldrh	r3, [r3, #6]
 8002b52:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002b56:	b29b      	uxth	r3, r3
 8002b58:	461a      	mov	r2, r3
 8002b5a:	9b03      	ldr	r3, [sp, #12]
 8002b5c:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002b5e:	9b00      	ldr	r3, [sp, #0]
 8002b60:	891b      	ldrh	r3, [r3, #8]
 8002b62:	f043 0301 	orr.w	r3, r3, #1
 8002b66:	b29b      	uxth	r3, r3
 8002b68:	461a      	mov	r2, r3
 8002b6a:	9b03      	ldr	r3, [sp, #12]
 8002b6c:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002b6e:	9b00      	ldr	r3, [sp, #0]
 8002b70:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8002b72:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8002b76:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8002b7a:	b29b      	uxth	r3, r3
 8002b7c:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002b7e:	9b03      	ldr	r3, [sp, #12]
 8002b80:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8002b82:	9b03      	ldr	r3, [sp, #12]
 8002b84:	2200      	movs	r2, #0
 8002b86:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8002b88:	9b03      	ldr	r3, [sp, #12]
 8002b8a:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8002b8c:	9b03      	ldr	r3, [sp, #12]
 8002b8e:	685b      	ldr	r3, [r3, #4]
}
 8002b90:	b004      	add	sp, #16
 8002b92:	4770      	bx	lr
 8002b94:	40011000 	.word	0x40011000
 8002b98:	40011400 	.word	0x40011400
 8002b9c:	0501bd00 	.word	0x0501bd00
 8002ba0:	0280de80 	.word	0x0280de80
 8002ba4:	f3af 8000 	nop.w
 8002ba8:	f3af 8000 	nop.w
 8002bac:	f3af 8000 	nop.w

08002bb0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8002bb0:	b500      	push	{lr}
 8002bb2:	b085      	sub	sp, #20
 8002bb4:	9001      	str	r0, [sp, #4]
 8002bb6:	460b      	mov	r3, r1
 8002bb8:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 8002bbc:	2300      	movs	r3, #0
 8002bbe:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 8002bc0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002bc4:	f003 0308 	and.w	r3, r3, #8
 8002bc8:	2b00      	cmp	r3, #0
 8002bca:	d003      	beq.n	8002bd4 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 8002bcc:	9b03      	ldr	r3, [sp, #12]
 8002bce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002bd2:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 8002bd4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002bd8:	f003 0301 	and.w	r3, r3, #1
 8002bdc:	2b00      	cmp	r3, #0
 8002bde:	d003      	beq.n	8002be8 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 8002be0:	9b03      	ldr	r3, [sp, #12]
 8002be2:	f043 0320 	orr.w	r3, r3, #32
 8002be6:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 8002be8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002bec:	f003 0302 	and.w	r3, r3, #2
 8002bf0:	2b00      	cmp	r3, #0
 8002bf2:	d003      	beq.n	8002bfc <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 8002bf4:	9b03      	ldr	r3, [sp, #12]
 8002bf6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002bfa:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 8002bfc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002c00:	f003 0304 	and.w	r3, r3, #4
 8002c04:	2b00      	cmp	r3, #0
 8002c06:	d003      	beq.n	8002c10 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 8002c08:	9b03      	ldr	r3, [sp, #12]
 8002c0a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c0e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8002c10:	9b01      	ldr	r3, [sp, #4]
 8002c12:	3304      	adds	r3, #4
 8002c14:	4618      	mov	r0, r3
 8002c16:	9903      	ldr	r1, [sp, #12]
 8002c18:	f7ff ff6a 	bl	8002af0 <osalEventBroadcastFlagsI>
}
 8002c1c:	b005      	add	sp, #20
 8002c1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c22:	bf00      	nop
 8002c24:	f3af 8000 	nop.w
 8002c28:	f3af 8000 	nop.w
 8002c2c:	f3af 8000 	nop.w

08002c30 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8002c30:	b500      	push	{lr}
 8002c32:	b087      	sub	sp, #28
 8002c34:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8002c36:	9b01      	ldr	r3, [sp, #4]
 8002c38:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002c3a:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
 8002c3c:	9b04      	ldr	r3, [sp, #16]
 8002c3e:	68db      	ldr	r3, [r3, #12]
 8002c40:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
 8002c44:	9b04      	ldr	r3, [sp, #16]
 8002c46:	681b      	ldr	r3, [r3, #0]
 8002c48:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8002c4c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002c50:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002c54:	2b00      	cmp	r3, #0
 8002c56:	d00e      	beq.n	8002c76 <serve_interrupt+0x46>
    osalSysLockFromISR();
 8002c58:	f7ff ff3a 	bl	8002ad0 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8002c5c:	9b01      	ldr	r3, [sp, #4]
 8002c5e:	3304      	adds	r3, #4
 8002c60:	4618      	mov	r0, r3
 8002c62:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002c66:	f7ff ff43 	bl	8002af0 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8002c6a:	9b04      	ldr	r3, [sp, #16]
 8002c6c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8002c70:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8002c72:	f7ff ff35 	bl	8002ae0 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
 8002c76:	f7ff ff2b 	bl	8002ad0 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002c7a:	e01f      	b.n	8002cbc <serve_interrupt+0x8c>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8002c7c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002c80:	f003 030f 	and.w	r3, r3, #15
 8002c84:	2b00      	cmp	r3, #0
 8002c86:	d005      	beq.n	8002c94 <serve_interrupt+0x64>
      set_error(sdp, sr);
 8002c88:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002c8c:	9801      	ldr	r0, [sp, #4]
 8002c8e:	4619      	mov	r1, r3
 8002c90:	f7ff ff8e 	bl	8002bb0 <set_error>
    b = u->DR;
 8002c94:	9b04      	ldr	r3, [sp, #16]
 8002c96:	685b      	ldr	r3, [r3, #4]
 8002c98:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
 8002c9c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002ca0:	f003 0320 	and.w	r3, r3, #32
 8002ca4:	2b00      	cmp	r3, #0
 8002ca6:	d005      	beq.n	8002cb4 <serve_interrupt+0x84>
      sdIncomingDataI(sdp, b);
 8002ca8:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8002cac:	9801      	ldr	r0, [sp, #4]
 8002cae:	4619      	mov	r1, r3
 8002cb0:	f7fe ff56 	bl	8001b60 <sdIncomingDataI>
    sr = u->SR;
 8002cb4:	9b04      	ldr	r3, [sp, #16]
 8002cb6:	681b      	ldr	r3, [r3, #0]
 8002cb8:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002cbc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002cc0:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8002cc4:	2b00      	cmp	r3, #0
 8002cc6:	d1d9      	bne.n	8002c7c <serve_interrupt+0x4c>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
 8002cc8:	f7ff ff0a 	bl	8002ae0 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8002ccc:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002cd0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002cd4:	2b00      	cmp	r3, #0
 8002cd6:	d024      	beq.n	8002d22 <serve_interrupt+0xf2>
 8002cd8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002cdc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002ce0:	2b00      	cmp	r3, #0
 8002ce2:	d01e      	beq.n	8002d22 <serve_interrupt+0xf2>
    msg_t b;
    osalSysLockFromISR();
 8002ce4:	f7ff fef4 	bl	8002ad0 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 8002ce8:	9b01      	ldr	r3, [sp, #4]
 8002cea:	3330      	adds	r3, #48	; 0x30
 8002cec:	4618      	mov	r0, r3
 8002cee:	f7fe fbbf 	bl	8001470 <chOQGetI>
 8002cf2:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 8002cf4:	9b02      	ldr	r3, [sp, #8]
 8002cf6:	2b00      	cmp	r3, #0
 8002cf8:	da0e      	bge.n	8002d18 <serve_interrupt+0xe8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8002cfa:	9b01      	ldr	r3, [sp, #4]
 8002cfc:	3304      	adds	r3, #4
 8002cfe:	4618      	mov	r0, r3
 8002d00:	2108      	movs	r1, #8
 8002d02:	f7ff fef5 	bl	8002af0 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8002d06:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002d0a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8002d0e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8002d12:	9b04      	ldr	r3, [sp, #16]
 8002d14:	60da      	str	r2, [r3, #12]
 8002d16:	e002      	b.n	8002d1e <serve_interrupt+0xee>
    }
    else
      u->DR = b;
 8002d18:	9a02      	ldr	r2, [sp, #8]
 8002d1a:	9b04      	ldr	r3, [sp, #16]
 8002d1c:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8002d1e:	f7ff fedf 	bl	8002ae0 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8002d22:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002d26:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002d2a:	2b00      	cmp	r3, #0
 8002d2c:	d01b      	beq.n	8002d66 <serve_interrupt+0x136>
    osalSysLockFromISR();
 8002d2e:	f7ff fecf 	bl	8002ad0 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 8002d32:	9b01      	ldr	r3, [sp, #4]
 8002d34:	3330      	adds	r3, #48	; 0x30
 8002d36:	4618      	mov	r0, r3
 8002d38:	f7ff feb2 	bl	8002aa0 <chOQIsEmptyI>
 8002d3c:	4603      	mov	r3, r0
 8002d3e:	2b00      	cmp	r3, #0
 8002d40:	d005      	beq.n	8002d4e <serve_interrupt+0x11e>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8002d42:	9b01      	ldr	r3, [sp, #4]
 8002d44:	3304      	adds	r3, #4
 8002d46:	4618      	mov	r0, r3
 8002d48:	2110      	movs	r1, #16
 8002d4a:	f7ff fed1 	bl	8002af0 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002d4e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002d52:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8002d56:	9b04      	ldr	r3, [sp, #16]
 8002d58:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 8002d5a:	9b04      	ldr	r3, [sp, #16]
 8002d5c:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8002d60:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8002d62:	f7ff febd 	bl	8002ae0 <osalSysUnlockFromISR>
  }
}
 8002d66:	b007      	add	sp, #28
 8002d68:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d6c:	f3af 8000 	nop.w

08002d70 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 8002d70:	b082      	sub	sp, #8
 8002d72:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8002d74:	4a03      	ldr	r2, [pc, #12]	; (8002d84 <notify2+0x14>)
 8002d76:	4b03      	ldr	r3, [pc, #12]	; (8002d84 <notify2+0x14>)
 8002d78:	68db      	ldr	r3, [r3, #12]
 8002d7a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d7e:	60d3      	str	r3, [r2, #12]
}
 8002d80:	b002      	add	sp, #8
 8002d82:	4770      	bx	lr
 8002d84:	40004400 	.word	0x40004400
 8002d88:	f3af 8000 	nop.w
 8002d8c:	f3af 8000 	nop.w

08002d90 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8002d90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8002d92:	4803      	ldr	r0, [pc, #12]	; (8002da0 <VectorD8+0x10>)
 8002d94:	f7ff ff4c 	bl	8002c30 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8002d98:	f7fe fcba 	bl	8001710 <_port_irq_epilogue>
}
 8002d9c:	bd08      	pop	{r3, pc}
 8002d9e:	bf00      	nop
 8002da0:	20000b50 	.word	0x20000b50
 8002da4:	f3af 8000 	nop.w
 8002da8:	f3af 8000 	nop.w
 8002dac:	f3af 8000 	nop.w

08002db0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8002db0:	b508      	push	{r3, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8002db2:	4804      	ldr	r0, [pc, #16]	; (8002dc4 <sd_lld_init+0x14>)
 8002db4:	2100      	movs	r1, #0
 8002db6:	4a04      	ldr	r2, [pc, #16]	; (8002dc8 <sd_lld_init+0x18>)
 8002db8:	f7fe fe82 	bl	8001ac0 <sdObjectInit>
  SD2.usart = USART2;
 8002dbc:	4b01      	ldr	r3, [pc, #4]	; (8002dc4 <sd_lld_init+0x14>)
 8002dbe:	4a03      	ldr	r2, [pc, #12]	; (8002dcc <sd_lld_init+0x1c>)
 8002dc0:	675a      	str	r2, [r3, #116]	; 0x74

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
  SD6.usart = USART6;
#endif
}
 8002dc2:	bd08      	pop	{r3, pc}
 8002dc4:	20000b50 	.word	0x20000b50
 8002dc8:	08002d71 	.word	0x08002d71
 8002dcc:	40004400 	.word	0x40004400

08002dd0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b083      	sub	sp, #12
 8002dd4:	9001      	str	r0, [sp, #4]
 8002dd6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8002dd8:	9b00      	ldr	r3, [sp, #0]
 8002dda:	2b00      	cmp	r3, #0
 8002ddc:	d101      	bne.n	8002de2 <sd_lld_start+0x12>
    config = &default_config;
 8002dde:	4b0d      	ldr	r3, [pc, #52]	; (8002e14 <sd_lld_start+0x44>)
 8002de0:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8002de2:	9b01      	ldr	r3, [sp, #4]
 8002de4:	7a1b      	ldrb	r3, [r3, #8]
 8002de6:	2b01      	cmp	r3, #1
 8002de8:	d10d      	bne.n	8002e06 <sd_lld_start+0x36>
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8002dea:	9b01      	ldr	r3, [sp, #4]
 8002dec:	4a0a      	ldr	r2, [pc, #40]	; (8002e18 <sd_lld_start+0x48>)
 8002dee:	4293      	cmp	r3, r2
 8002df0:	d109      	bne.n	8002e06 <sd_lld_start+0x36>
      rccEnableUSART2(FALSE);
 8002df2:	4a0a      	ldr	r2, [pc, #40]	; (8002e1c <sd_lld_start+0x4c>)
 8002df4:	4b09      	ldr	r3, [pc, #36]	; (8002e1c <sd_lld_start+0x4c>)
 8002df6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002df8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002dfc:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 8002dfe:	2026      	movs	r0, #38	; 0x26
 8002e00:	210c      	movs	r1, #12
 8002e02:	f7fe ff0d 	bl	8001c20 <nvicEnableVector>
      rccEnableUSART6(FALSE);
      nvicEnableVector(STM32_USART6_NUMBER, STM32_SERIAL_USART6_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8002e06:	9801      	ldr	r0, [sp, #4]
 8002e08:	9900      	ldr	r1, [sp, #0]
 8002e0a:	f7ff fe81 	bl	8002b10 <usart_init>
}
 8002e0e:	b003      	add	sp, #12
 8002e10:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e14:	080030c0 	.word	0x080030c0
 8002e18:	20000b50 	.word	0x20000b50
 8002e1c:	40023800 	.word	0x40023800

08002e20 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8002e20:	b508      	push	{r3, lr}

  stm32_clock_init();
 8002e22:	f7ff f9d5 	bl	80021d0 <stm32_clock_init>
}
 8002e26:	bd08      	pop	{r3, pc}
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8002e30:	4770      	bx	lr
 8002e32:	bf00      	nop
 8002e34:	f3af 8000 	nop.w
 8002e38:	f3af 8000 	nop.w
 8002e3c:	f3af 8000 	nop.w

08002e40 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8002e40:	b082      	sub	sp, #8
 8002e42:	2300      	movs	r3, #0
 8002e44:	9301      	str	r3, [sp, #4]
 8002e46:	9b01      	ldr	r3, [sp, #4]
 8002e48:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e4c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 8002e4e:	b002      	add	sp, #8
 8002e50:	4770      	bx	lr
 8002e52:	bf00      	nop
 8002e54:	f3af 8000 	nop.w
 8002e58:	f3af 8000 	nop.w
 8002e5c:	f3af 8000 	nop.w

08002e60 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8002e60:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8002e62:	f7ff ffed 	bl	8002e40 <port_enable>
}
 8002e66:	bd08      	pop	{r3, pc}
 8002e68:	f3af 8000 	nop.w
 8002e6c:	f3af 8000 	nop.w

08002e70 <osalSysEnable>:
/**
 * @brief   Enables interrupts globally.
 *
 * @special
 */
static inline void osalSysEnable(void) {
 8002e70:	b508      	push	{r3, lr}

  chSysEnable();
 8002e72:	f7ff fff5 	bl	8002e60 <chSysEnable>
}
 8002e76:	bd08      	pop	{r3, pc}
 8002e78:	f3af 8000 	nop.w
 8002e7c:	f3af 8000 	nop.w

08002e80 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 8002e80:	b500      	push	{lr}
 8002e82:	b083      	sub	sp, #12
 8002e84:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 8002e86:	9801      	ldr	r0, [sp, #4]
 8002e88:	f7fd ff32 	bl	8000cf0 <chThdSleep>
}
 8002e8c:	b003      	add	sp, #12
 8002e8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e92:	bf00      	nop
 8002e94:	f3af 8000 	nop.w
 8002e98:	f3af 8000 	nop.w
 8002e9c:	f3af 8000 	nop.w

08002ea0 <Thread1>:
  /*
   * First I am alive thread
   */
  
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002ea0:	b500      	push	{lr}
 8002ea2:	b083      	sub	sp, #12
 8002ea4:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 8002ea6:	4b0a      	ldr	r3, [pc, #40]	; (8002ed0 <Thread1+0x30>)
 8002ea8:	699b      	ldr	r3, [r3, #24]
 8002eaa:	4a0a      	ldr	r2, [pc, #40]	; (8002ed4 <Thread1+0x34>)
 8002eac:	619a      	str	r2, [r3, #24]
  while (TRUE) {
    palSetPad(GPIOD, GPIOD_LED4);       /* Orange.  */
 8002eae:	4b0a      	ldr	r3, [pc, #40]	; (8002ed8 <Thread1+0x38>)
 8002eb0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002eb4:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8002eb6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002eba:	f7fd ff19 	bl	8000cf0 <chThdSleep>
    palClearPad(GPIOD, GPIOD_LED4);     /* Orange.  */
 8002ebe:	4b06      	ldr	r3, [pc, #24]	; (8002ed8 <Thread1+0x38>)
 8002ec0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002ec4:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8002ec6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002eca:	f7fd ff11 	bl	8000cf0 <chThdSleep>
  }
 8002ece:	e7ee      	b.n	8002eae <Thread1+0xe>
 8002ed0:	20000800 	.word	0x20000800
 8002ed4:	08002fa0 	.word	0x08002fa0
 8002ed8:	40020c00 	.word	0x40020c00
 8002edc:	f3af 8000 	nop.w

08002ee0 <startBlinker>:
}

  /*
   * Creates the example thread.
   */
void startBlinker(void) {
 8002ee0:	b500      	push	{lr}
 8002ee2:	b083      	sub	sp, #12
  chThdCreateStatic(waThread1, sizeof(waThread1),
 8002ee4:	2300      	movs	r3, #0
 8002ee6:	9300      	str	r3, [sp, #0]
 8002ee8:	4804      	ldr	r0, [pc, #16]	; (8002efc <startBlinker+0x1c>)
 8002eea:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002eee:	224a      	movs	r2, #74	; 0x4a
 8002ef0:	4b03      	ldr	r3, [pc, #12]	; (8002f00 <startBlinker+0x20>)
 8002ef2:	f7fd fedd 	bl	8000cb0 <chThdCreateStatic>
                    NORMALPRIO + 10, Thread1, NULL);
}  
 8002ef6:	b003      	add	sp, #12
 8002ef8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002efc:	20000bc8 	.word	0x20000bc8
 8002f00:	08002ea1 	.word	0x08002ea1
 8002f04:	f3af 8000 	nop.w
 8002f08:	f3af 8000 	nop.w
 8002f0c:	f3af 8000 	nop.w

08002f10 <main>:

int main(void) {
 8002f10:	b510      	push	{r4, lr}
  /*
   * System initializations.
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   */
  halInit();
 8002f12:	f7fe fc45 	bl	80017a0 <halInit>
  chSysInit();
 8002f16:	f7fd fb0b 	bl	8000530 <chSysInit>
  /*
   * Enabling interrupts, initialization done.
   */
  osalSysEnable();
 8002f1a:	f7ff ffa9 	bl	8002e70 <osalSysEnable>

  startBlinker();
 8002f1e:	f7ff ffdf 	bl	8002ee0 <startBlinker>

  /*
   * Activates the serial driver 2 using the driver default configuration.
   * PA2(TX) and PA3(RX) are routed to USART2.
   */
  sdStart(&SD2, NULL);
 8002f22:	4815      	ldr	r0, [pc, #84]	; (8002f78 <main+0x68>)
 8002f24:	2100      	movs	r1, #0
 8002f26:	f7fe fe03 	bl	8001b30 <sdStart>
  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
 8002f2a:	4814      	ldr	r0, [pc, #80]	; (8002f7c <main+0x6c>)
 8002f2c:	2104      	movs	r1, #4
 8002f2e:	f240 3282 	movw	r2, #898	; 0x382
 8002f32:	f7ff fc0d 	bl	8002750 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 8002f36:	4811      	ldr	r0, [pc, #68]	; (8002f7c <main+0x6c>)
 8002f38:	2108      	movs	r1, #8
 8002f3a:	f240 3282 	movw	r2, #898	; 0x382
 8002f3e:	f7ff fc07 	bl	8002750 <_pal_lld_setgroupmode>
  /*
   * Normal main() thread activity, in this demo it just performs
   * a shell respawn upon its termination.
   */
  while (true) {
    chnWriteTimeout(&SD2, (uint8_t *)"Hello World!\r\n", 14, TIME_INFINITE);
 8002f42:	4b0d      	ldr	r3, [pc, #52]	; (8002f78 <main+0x68>)
 8002f44:	681b      	ldr	r3, [r3, #0]
 8002f46:	699c      	ldr	r4, [r3, #24]
 8002f48:	480b      	ldr	r0, [pc, #44]	; (8002f78 <main+0x68>)
 8002f4a:	490d      	ldr	r1, [pc, #52]	; (8002f80 <main+0x70>)
 8002f4c:	220e      	movs	r2, #14
 8002f4e:	f04f 33ff 	mov.w	r3, #4294967295
 8002f52:	47a0      	blx	r4

    palSetPad(GPIOD, GPIOD_LED3);       /* Orange.  */
 8002f54:	4b0b      	ldr	r3, [pc, #44]	; (8002f84 <main+0x74>)
 8002f56:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8002f5a:	831a      	strh	r2, [r3, #24]
    osalThreadSleepMilliseconds(500);
 8002f5c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002f60:	f7ff ff8e 	bl	8002e80 <osalThreadSleep>
    palClearPad(GPIOD, GPIOD_LED3);     /* Orange.  */
 8002f64:	4b07      	ldr	r3, [pc, #28]	; (8002f84 <main+0x74>)
 8002f66:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8002f6a:	835a      	strh	r2, [r3, #26]
    osalThreadSleepMilliseconds(500);
 8002f6c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002f70:	f7ff ff86 	bl	8002e80 <osalThreadSleep>
  }
 8002f74:	e7e5      	b.n	8002f42 <main+0x32>
 8002f76:	bf00      	nop
 8002f78:	20000b50 	.word	0x20000b50
 8002f7c:	40020000 	.word	0x40020000
 8002f80:	08002fa8 	.word	0x08002fa8
 8002f84:	40020c00 	.word	0x40020c00
 8002f88:	f3af 8000 	nop.w
 8002f8c:	f3af 8000 	nop.w
 8002f90:	656c6469 	.word	0x656c6469
	...
 8002fa0:	6e696c62 	.word	0x6e696c62
 8002fa4:	0072656b 	.word	0x0072656b
 8002fa8:	6c6c6548 	.word	0x6c6c6548
 8002fac:	6f57206f 	.word	0x6f57206f
 8002fb0:	21646c72 	.word	0x21646c72
 8002fb4:	00000a0d 	.word	0x00000a0d
	...

08002fc0 <ch_debug>:
 8002fc0:	6e69616d 18001600 08440404 1814100c     main......D.....
 8002fd0:	1e1d1c00 00000000 00000000 00000000     ................

08002fe0 <vmt>:
 8002fe0:	08001951 08001981 080019b1 080019e1     Q...............
 8002ff0:	08001a01 08001a31 08001a51 08001a81     ....1...Q.......

08003000 <_stm32_dma_streams>:
 8003000:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 8003010:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 8003020:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 8003030:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 8003040:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8003050:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8003060:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8003070:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8003080:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8003090:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 80030a0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 80030b0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

080030c0 <default_config>:
 80030c0:	00009600 40000000 00000000 00000000     .......@........

080030d0 <pal_default_config>:
 80030d0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 80030e0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 80030f0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8003100:	04000000 00000040 02208001 00000000     ....@..... .....
 8003110:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 8003120:	00060600 55000100 00000000 ffffffff     .......U........
 8003130:	00555055 00000fff 00000000 00000000     UPU.............
 8003140:	00000040 00000000 ffffffff 00000000     @...............
 8003150:	0000ffff 00000000 00000000 00000000     ................
 8003160:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8003180:	ffffffff 00000000 0000ffff 00000000     ................
	...
 800319c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 80031b8:	ffffffff 00000000 0000ffff 00000000     ................
 80031c8:	00000000                                ....
